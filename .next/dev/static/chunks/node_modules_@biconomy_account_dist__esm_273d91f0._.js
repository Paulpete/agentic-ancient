(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/getAAError.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DOCS_URL",
    ()=>DOCS_URL,
    "ERRORS_URL",
    ()=>ERRORS_URL,
    "getAAError",
    ()=>getAAError
]);
const ERRORS_URL = "https://raw.githubusercontent.com/bcnmy/aa-errors/main/docs/errors.json";
const DOCS_URL = "https://docs.biconomy.io/troubleshooting/commonerrors";
const UNKOWN_ERROR_CODE = "520";
const knownErrors = [];
const matchError = (message)=>knownErrors.find((knownError)=>message.toLowerCase().indexOf(knownError.regex.toLowerCase()) > -1) ?? null;
const buildErrorStrings = (error, status, service)=>[
        `${status}: ${error.description}\n`,
        error.causes?.length ? [
            "Potential cause(s): \n",
            ...error.causes,
            ""
        ].join("\n") : "",
        error.solutions?.length ? [
            "Potential solution(s): \n",
            ...error.solutions
        ].join("\n") : "",
        service ? `\nSent via: ${service}` : ""
    ].filter(Boolean);
const getAAError = async (message, httpStatus, service)=>{
    if (!knownErrors.length) {
        const errors = await (await fetch(ERRORS_URL)).json();
        knownErrors.push(...errors);
    }
    const details = `${service} - ${typeof message}` === "string" ? message : JSON.stringify(message);
    const matchedError = matchError(details);
    const status = matchedError?.regex ?? (httpStatus ?? UNKOWN_ERROR_CODE).toString();
    const metaMessages = matchedError ? buildErrorStrings(matchedError, status, service) : [];
    const title = matchedError ? matchedError.name : "Unknown Error";
    const docsSlug = matchedError?.docsUrl ?? DOCS_URL;
    return new Error([
        title,
        status,
        docsSlug,
        metaMessages,
        details
    ].join("\n"));
}; //# sourceMappingURL=getAAError.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Helpers.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isDebugging",
    ()=>isDebugging
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
const isDebugging = ()=>!!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env.NEXT_PUBLIC_BICONOMY_SDK_DEBUG || !!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env.REACT_APP_BICONOMY_SDK_DEBUG || !!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env.BICONOMY_SDK_DEBUG; //# sourceMappingURL=Helpers.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Logger",
    ()=>Logger
]);
/* eslint-disable no-console */ /**
 * Single class to be used for logging purpose.
 *
 * @param {any} message Message to be logged
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Helpers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Helpers.js [client] (ecmascript)");
;
// biome-ignore lint/complexity/noStaticOnlyClass: <explanation>
class Logger {
    /**
     * \x1b[0m is an escape sequence to reset the color of the text
     * All color codes used - 31 - Red, 33 - Yellow, 34 - Blue, 35 - Magenta, 36 - Cyan
     * log -   Magenta[time]               Cyan[message]:  [value]
     * warn -  Magenta[time] Yellow[WARN]: Cyan[message]:  [value]
     * error - Magenta[time] Red[ERROR]:   Cyan[message]:  [value]
     */ // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    static log(message, value = "") {
        const timestamp = new Date().toISOString();
        const logMessage = `\x1b[35m[${timestamp}]\x1b[0m \x1b[36m${message}\x1b[0m:`;
        if (Logger.isDebug) {
            console.log(logMessage, value === undefined ? "" : value);
        }
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    static warn(message, value = "") {
        const timestamp = new Date().toISOString();
        const warnMessage = `\x1b[35m[${timestamp}]\x1b[0m \x1b[33mWARN\x1b[0m: \x1b[36m${message}\x1b[0m`;
        if (Logger.isDebug) {
            console.warn(warnMessage, value === undefined ? "" : value);
        }
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    static error(message, value = "") {
        const timestamp = new Date().toISOString();
        const errorMessage = `\x1b[35m[${timestamp}]\x1b[0m \x1b[31mERROR\x1b[0m: \x1b[36m${message}\x1b[0m`;
        if (Logger.isDebug) {
            console.error(errorMessage, value === undefined ? "" : value);
        }
    }
}
// By default, the logger is not in debug mode.
Object.defineProperty(Logger, "isDebug", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Helpers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isDebugging"])()
});
;
 //# sourceMappingURL=Logger.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/HttpRequests.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HttpMethod",
    ()=>HttpMethod,
    "sendRequest",
    ()=>sendRequest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/getAAError.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)");
;
;
var HttpMethod;
(function(HttpMethod) {
    HttpMethod["Get"] = "get";
    HttpMethod["Post"] = "post";
    HttpMethod["Delete"] = "delete";
})(HttpMethod || (HttpMethod = {}));
async function sendRequest({ url, method, body }, service) {
    const stringifiedBody = JSON.stringify(body);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log(`${service} RPC Request`, {
        url,
        body: stringifiedBody
    });
    const response = await fetch(url, {
        method,
        headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
        },
        body: stringifiedBody
    });
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    let jsonResponse;
    try {
        jsonResponse = await response.json();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log(`${service} RPC Response`, jsonResponse);
    } catch (error) {
        if (!response.ok) {
            throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(response.statusText, response.status, service);
        }
    }
    if (response.ok) {
        return jsonResponse;
    }
    if (jsonResponse.error) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(`Error coming from ${service}: ${jsonResponse.error.message}`);
    }
    if (jsonResponse.message) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(jsonResponse.message, response.status, service);
    }
    if (jsonResponse.msg) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(jsonResponse.msg, response.status, service);
    }
    if (jsonResponse.data) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(jsonResponse.data, response.status, service);
    }
    if (jsonResponse.detail) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(jsonResponse.detail, response.status, service);
    }
    if (jsonResponse.message) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(jsonResponse.message, response.status, service);
    }
    if (jsonResponse.nonFieldErrors) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(jsonResponse.nonFieldErrors, response.status, service);
    }
    if (jsonResponse.delegate) {
        throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(jsonResponse.delegate, response.status, service);
    }
    throw await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$getAAError$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAAError"])(response.statusText, response.status, service);
} //# sourceMappingURL=HttpRequests.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/getChain.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getChain",
    ()=>getChain,
    "getCustomChain",
    ()=>getCustomChain,
    "stringOrStringsToArray",
    ()=>stringOrStringsToArray
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/index.js [client] (ecmascript)");
;
const CUSTOM_CHAINS = [
    {
        id: 81_457,
        name: "Blast",
        nativeCurrency: {
            decimals: 18,
            name: "Ethereum",
            symbol: "ETH"
        },
        rpcUrls: {
            public: {
                http: [
                    "https://rpc.blast.io"
                ]
            },
            default: {
                http: [
                    "https://rpc.blast.io"
                ]
            }
        },
        blockExplorers: {
            etherscan: {
                name: "Blastscan",
                url: "https://blastscan.io/"
            },
            default: {
                name: "Blastscan",
                url: "https://blastscan.io/"
            }
        },
        contracts: {
            multicall3: {
                address: "0xca11bde05977b3631167028862be2a173976ca11",
                blockCreated: 88_189
            }
        }
    }
];
const getChain = (chainId)=>{
    const allChains = [
        ...Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__),
        ...CUSTOM_CHAINS
    ];
    for (const chain of allChains){
        if (chain.id === chainId) {
            return chain;
        }
    }
    throw new Error("Chain not found. Please add a customChain into your config using the getCustomChain(...) helper, and the BiconomySmartAccountV2Config['customChain'] config option");
};
const stringOrStringsToArray = (str)=>Array.isArray(str) ? str : [
        str
    ];
const getCustomChain = (name, id, rpcUrl, blockExplorer, nativeCurrency, contracts)=>{
    const chain = {
        id,
        name,
        nativeCurrency: nativeCurrency ?? {
            decimals: 18,
            name: "Ethereum",
            symbol: "ETH"
        },
        rpcUrls: {
            default: {
                http: stringOrStringsToArray(rpcUrl)
            }
        },
        blockExplorers: {
            default: {
                name: "Explorer",
                url: stringOrStringsToArray(blockExplorer)[0]
            }
        },
        ...contracts && {
            contracts
        } || {}
    };
    CUSTOM_CHAINS.push(chain);
    return chain;
}; //# sourceMappingURL=getChain.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/Constants.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_ENTRYPOINT_ADDRESS",
    ()=>DEFAULT_ENTRYPOINT_ADDRESS,
    "UserOpReceiptIntervals",
    ()=>UserOpReceiptIntervals,
    "UserOpReceiptMaxDurationIntervals",
    ()=>UserOpReceiptMaxDurationIntervals,
    "UserOpWaitForTxHashIntervals",
    ()=>UserOpWaitForTxHashIntervals,
    "UserOpWaitForTxHashMaxDurationIntervals",
    ()=>UserOpWaitForTxHashMaxDurationIntervals
]);
const UserOpReceiptIntervals = {
    [1]: 10000
};
const UserOpWaitForTxHashIntervals = {
    [1]: 1000
};
const UserOpReceiptMaxDurationIntervals = {
    [1]: 300000,
    [80002]: 50000,
    [137]: 60000,
    [56]: 50000,
    [97]: 50000,
    [421613]: 50000,
    [42161]: 50000,
    [59140]: 50000 // linea testnet
};
const UserOpWaitForTxHashMaxDurationIntervals = {
    [1]: 20000
};
const DEFAULT_ENTRYPOINT_ADDRESS = "0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789"; //# sourceMappingURL=Constants.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/HelperFunction.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Will convert the userOp hex, bigInt and number values to hex strings
__turbopack_context__.s([
    "getTimestampInSeconds",
    ()=>getTimestampInSeconds,
    "transformUserOP",
    ()=>transformUserOP
]);
const transformUserOP = (userOp)=>{
    try {
        const userOperation = {
            ...userOp
        };
        const keys = [
            "nonce",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas"
        ];
        for (const key of keys){
            if (userOperation[key] && userOperation[key] !== "0x") {
                userOperation[key] = `0x${BigInt(userOp[key]).toString(16)}`;
            }
        }
        return userOperation;
    } catch (error) {
        throw `Failed to transform user operation: ${error}`;
    }
};
const getTimestampInSeconds = ()=>{
    return Math.floor(Date.now() / 1000);
}; //# sourceMappingURL=HelperFunction.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/Utils.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Extracts the chain ID from a given URL.
 *
 * @param url - The URL to extract the chain ID from.
 * @returns The extracted chain ID as a number.
 * @throws {Error} If the chain ID is not found in the URL or is invalid.
 *
 * @example
 * // Returns 80001
 * extractChainIdFromUrl("https://example.com/api/v2/80001/rpc")
 */ __turbopack_context__.s([
    "extractChainIdFromBundlerUrl",
    ()=>extractChainIdFromBundlerUrl,
    "extractChainIdFromPaymasterUrl",
    ()=>extractChainIdFromPaymasterUrl,
    "extractChainIdFromUrl",
    ()=>extractChainIdFromUrl
]);
const extractChainIdFromUrl = (url)=>{
    try {
        const regex = /\/(\d+)\//;
        const match = regex.exec(new URL(url).pathname);
        if (!match) {
            throw new Error("Chain ID not found in URL");
        }
        const chainId = Number.parseInt(match[1], 10);
        if (Number.isNaN(chainId)) {
            throw new Error("Invalid chain ID");
        }
        return chainId;
    } catch (error) {
        if (error instanceof Error) {
            throw new Error(`Invalid chain id: ${error.message}`);
        }
        throw new Error("Invalid chain id");
    }
};
const extractChainIdFromBundlerUrl = (url)=>extractChainIdFromUrl(url);
const extractChainIdFromPaymasterUrl = (url)=>extractChainIdFromUrl(url); //# sourceMappingURL=Utils.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/bundler/Bundler.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Bundler",
    ()=>Bundler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createPublicClient.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/HttpRequests.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/getChain.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/HelperFunction.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/Utils.js [client] (ecmascript)");
;
;
;
;
;
const POLL_INTERVAL = 2000;
class Bundler {
    constructor(bundlerConfig){
        Object.defineProperty(this, "bundlerConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // eslint-disable-next-line no-unused-vars
        Object.defineProperty(this, "UserOpReceiptIntervals", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "UserOpWaitForTxHashIntervals", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "UserOpReceiptMaxDurationIntervals", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "UserOpWaitForTxHashMaxDurationIntervals", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const parsedChainId = bundlerConfig?.chainId || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractChainIdFromBundlerUrl"])(bundlerConfig.bundlerUrl);
        this.bundlerConfig = {
            ...bundlerConfig,
            chainId: parsedChainId
        };
        this.provider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createPublicClient"])({
            chain: bundlerConfig.viemChain ?? bundlerConfig.customChain ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(parsedChainId),
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])((bundlerConfig.viemChain || bundlerConfig.customChain || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(parsedChainId)).rpcUrls.default.http[0])
        });
        this.UserOpReceiptIntervals = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["UserOpReceiptIntervals"],
            ...bundlerConfig.userOpReceiptIntervals
        };
        this.UserOpWaitForTxHashIntervals = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["UserOpWaitForTxHashIntervals"],
            ...bundlerConfig.userOpWaitForTxHashIntervals
        };
        this.UserOpReceiptMaxDurationIntervals = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["UserOpReceiptMaxDurationIntervals"],
            ...bundlerConfig.userOpReceiptMaxDurationIntervals
        };
        this.UserOpWaitForTxHashMaxDurationIntervals = {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["UserOpWaitForTxHashMaxDurationIntervals"],
            ...bundlerConfig.userOpWaitForTxHashMaxDurationIntervals
        };
        this.bundlerConfig.entryPointAddress = bundlerConfig.entryPointAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ENTRYPOINT_ADDRESS"];
    }
    getBundlerUrl() {
        return `${this.bundlerConfig.bundlerUrl}`;
    }
    /**
     * @param userOpHash
     * @description This function will fetch gasPrices from bundler
     * @returns Promise<UserOpGasPricesResponse>
     */ async estimateUserOpGas(_userOp, stateOverrideSet) {
        // expected dummySig and possibly dummmy paymasterAndData should be provided by the caller
        // bundler doesn't know account and paymaster implementation
        const userOp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformUserOP"])(_userOp);
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
            url: bundlerUrl,
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
            body: {
                method: "eth_estimateUserOperationGas",
                params: stateOverrideSet ? [
                    userOp,
                    this.bundlerConfig.entryPointAddress,
                    stateOverrideSet
                ] : [
                    userOp,
                    this.bundlerConfig.entryPointAddress
                ],
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                jsonrpc: "2.0"
            }
        }, "Bundler");
        const userOpGasResponse = response.result;
        for(const key in userOpGasResponse){
            if (key === "maxFeePerGas" || key === "maxPriorityFeePerGas") continue;
            if (userOpGasResponse[key] === undefined || userOpGasResponse[key] === null) {
                throw new Error(`Got undefined ${key} from bundler`);
            }
        }
        return userOpGasResponse;
    }
    /**
     *
     * @param userOp
     * @description This function will send signed userOp to bundler to get mined on chain
     * @returns Promise<UserOpResponse>
     */ async sendUserOp(_userOp, simulationParam) {
        const chainId = this.bundlerConfig.chainId;
        // transformUserOP will convert all bigNumber values to string
        const userOp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["transformUserOP"])(_userOp);
        const simType = {
            simulation_type: simulationParam || "validation"
        };
        const params = [
            userOp,
            this.bundlerConfig.entryPointAddress,
            simType
        ];
        const bundlerUrl = this.getBundlerUrl();
        const sendUserOperationResponse = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
            url: bundlerUrl,
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
            body: {
                method: "eth_sendUserOperation",
                params: params,
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                jsonrpc: "2.0"
            }
        }, "Bundler");
        const response = {
            userOpHash: sendUserOperationResponse.result,
            wait: (confirmations)=>{
                // Note: maxDuration can be defined per chainId
                const maxDuration = this.UserOpReceiptMaxDurationIntervals[chainId] || 30000; // default 30 seconds
                let totalDuration = 0;
                return new Promise((resolve, reject)=>{
                    const intervalValue = this.UserOpReceiptIntervals[chainId] || POLL_INTERVAL;
                    const intervalId = setInterval(async ()=>{
                        try {
                            const userOpResponse = await this.getUserOpReceipt(sendUserOperationResponse.result);
                            if (userOpResponse?.receipt?.blockNumber) {
                                if (confirmations) {
                                    const latestBlock = await this.provider.getBlockNumber();
                                    const confirmedBlocks = Number(latestBlock) - userOpResponse.receipt.blockNumber;
                                    if (confirmations >= confirmedBlocks) {
                                        clearInterval(intervalId);
                                        resolve(userOpResponse);
                                        return;
                                    }
                                } else {
                                    clearInterval(intervalId);
                                    resolve(userOpResponse);
                                    return;
                                }
                            }
                        } catch (error) {
                            clearInterval(intervalId);
                            reject(error);
                            return;
                        }
                        totalDuration += intervalValue;
                        if (totalDuration >= maxDuration) {
                            clearInterval(intervalId);
                            reject(new Error(`Exceeded maximum duration (${maxDuration / 1000} sec) waiting to get receipt for userOpHash ${sendUserOperationResponse.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`));
                        }
                    }, intervalValue);
                });
            },
            waitForTxHash: ()=>{
                const maxDuration = this.UserOpWaitForTxHashMaxDurationIntervals[chainId] || 20000; // default 20 seconds
                let totalDuration = 0;
                return new Promise((resolve, reject)=>{
                    const intervalValue = this.UserOpWaitForTxHashIntervals[chainId] || 500; // default 0.5 seconds
                    const intervalId = setInterval(async ()=>{
                        try {
                            const userOpStatus = await this.getUserOpStatus(sendUserOperationResponse.result);
                            if (userOpStatus?.state && userOpStatus.transactionHash) {
                                clearInterval(intervalId);
                                resolve(userOpStatus);
                                return;
                            }
                        } catch (error) {
                            clearInterval(intervalId);
                            reject(error);
                            return;
                        }
                        totalDuration += intervalValue;
                        if (totalDuration >= maxDuration) {
                            clearInterval(intervalId);
                            reject(new Error(`Exceeded maximum duration (${maxDuration / 1000} sec) waiting to get receipt for userOpHash ${sendUserOperationResponse.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`));
                        }
                    }, intervalValue);
                });
            }
        };
        return response;
    }
    /**
     *
     * @param userOpHash
     * @description This function will return userOpReceipt for a given userOpHash
     * @returns Promise<UserOpReceipt>
     */ async getUserOpReceipt(userOpHash) {
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
            url: bundlerUrl,
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
            body: {
                method: "eth_getUserOperationReceipt",
                params: [
                    userOpHash
                ],
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                jsonrpc: "2.0"
            }
        }, "Bundler");
        const userOpReceipt = response.result;
        return userOpReceipt;
    }
    /**
     *
     * @param userOpHash
     * @description This function will return userOpReceipt for a given userOpHash
     * @returns Promise<UserOpReceipt>
     */ async getUserOpStatus(userOpHash) {
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
            url: bundlerUrl,
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
            body: {
                method: "biconomy_getUserOperationStatus",
                params: [
                    userOpHash
                ],
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                jsonrpc: "2.0"
            }
        }, "Bundler");
        const userOpStatus = response.result;
        return userOpStatus;
    }
    /**
     *
     * @param userOpHash
     * @description this function will return UserOpByHashResponse for given UserOpHash
     * @returns Promise<UserOpByHashResponse>
     */ async getUserOpByHash(userOpHash) {
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
            url: bundlerUrl,
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
            body: {
                method: "eth_getUserOperationByHash",
                params: [
                    userOpHash
                ],
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                jsonrpc: "2.0"
            }
        }, "Bundler");
        const userOpByHashResponse = response.result;
        return userOpByHashResponse;
    }
    /**
     * @description This function will return the gas fee values
     */ async getGasFeeValues() {
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
            url: bundlerUrl,
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
            body: {
                method: "biconomy_getGasFeeValues",
                params: [],
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$HelperFunction$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                jsonrpc: "2.0"
            }
        }, "Bundler");
        return response.result;
    }
    static async create(config) {
        return new Bundler(config);
    }
} //# sourceMappingURL=Bundler.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ADDRESS_RESOLVER_ADDRESS",
    ()=>ADDRESS_RESOLVER_ADDRESS,
    "ADDRESS_ZERO",
    ()=>ADDRESS_ZERO,
    "BICONOMY_FACTORY_ADDRESSES",
    ()=>BICONOMY_FACTORY_ADDRESSES,
    "BICONOMY_IMPLEMENTATION_ADDRESSES",
    ()=>BICONOMY_IMPLEMENTATION_ADDRESSES,
    "BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION",
    ()=>BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION,
    "BICONOMY_TOKEN_PAYMASTER",
    ()=>BICONOMY_TOKEN_PAYMASTER,
    "DEFAULT_BICONOMY_FACTORY_ADDRESS",
    ()=>DEFAULT_BICONOMY_FACTORY_ADDRESS,
    "DEFAULT_BICONOMY_IMPLEMENTATION_ADDRESS",
    ()=>DEFAULT_BICONOMY_IMPLEMENTATION_ADDRESS,
    "DEFAULT_ENTRYPOINT_ADDRESS",
    ()=>DEFAULT_ENTRYPOINT_ADDRESS,
    "DEFAULT_FALLBACK_HANDLER_ADDRESS",
    ()=>DEFAULT_FALLBACK_HANDLER_ADDRESS,
    "DefaultGasLimit",
    ()=>DefaultGasLimit,
    "EIP1559_UNSUPPORTED_NETWORKS",
    ()=>EIP1559_UNSUPPORTED_NETWORKS,
    "ENTRYPOINT_ADDRESSES",
    ()=>ENTRYPOINT_ADDRESSES,
    "ENTRYPOINT_ADDRESSES_BY_VERSION",
    ()=>ENTRYPOINT_ADDRESSES_BY_VERSION,
    "ERC20_ABI",
    ()=>ERC20_ABI,
    "ERROR_MESSAGES",
    ()=>ERROR_MESSAGES,
    "MAGIC_BYTES",
    ()=>MAGIC_BYTES,
    "NATIVE_TOKEN_ALIAS",
    ()=>NATIVE_TOKEN_ALIAS,
    "PROXY_CREATION_CODE",
    ()=>PROXY_CREATION_CODE,
    "TAIKO_FACTORY_ADDRESS",
    ()=>TAIKO_FACTORY_ADDRESS
]);
const ADDRESS_ZERO = "0x0000000000000000000000000000000000000000";
const MAGIC_BYTES = "0x6492649264926492649264926492649264926492649264926492649264926492";
const DEFAULT_ENTRYPOINT_ADDRESS = "0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789";
const ENTRYPOINT_ADDRESSES = {
    "0x27a4db290b89ae3373ce4313cbeae72112ae7da9": "V0_0_5",
    "0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789": "V0_0_6"
};
const TAIKO_FACTORY_ADDRESS = "0x000008B3078bA5ed444FFf7658F76385F6004e7A"; //https://biconomyworkspace.slack.com/archives/C061BSA9279/p1721234773541039
const DEFAULT_BICONOMY_FACTORY_ADDRESS = "0x000000a56Aaca3e9a4C479ea6b6CD0DbcB6634F5";
const DEFAULT_FALLBACK_HANDLER_ADDRESS = "0x0bBa6d96BD616BedC6BFaa341742FD43c60b83C1";
const BICONOMY_FACTORY_ADDRESSES = {
    "0x000000f9ee1842bb72f6bbdd75e6d3d4e3e9594c": "V1_0_0",
    "0x000000a56Aaca3e9a4C479ea6b6CD0DbcB6634F5": "V2_0_0"
};
const BICONOMY_TOKEN_PAYMASTER = "0x00000f7365cA6C59A2C93719ad53d567ed49c14C";
const DEFAULT_BICONOMY_IMPLEMENTATION_ADDRESS = "0x0000002512019Dafb59528B82CB92D3c5D2423aC";
const BICONOMY_IMPLEMENTATION_ADDRESSES = {
    "0x00006b7e42e01957da540dc6a8f7c30c4d816af5": "V1_0_0",
    "0x0000002512019Dafb59528B82CB92D3c5D2423aC": "V2_0_0"
};
const ENTRYPOINT_ADDRESSES_BY_VERSION = {
    V0_0_5: "0x27a4db290b89ae3373ce4313cbeae72112ae7da9",
    V0_0_6: "0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789"
};
const BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION = Object.fromEntries(Object.entries(BICONOMY_IMPLEMENTATION_ADDRESSES).map(([k, v])=>[
        v,
        k
    ]));
const EIP1559_UNSUPPORTED_NETWORKS = [
    97,
    56,
    1442,
    1101
];
const PROXY_CREATION_CODE = "0x6080346100aa57601f61012038819003918201601f19168301916001600160401b038311848410176100af578084926020946040528339810103126100aa57516001600160a01b0381168082036100aa5715610065573055604051605a90816100c68239f35b60405162461bcd60e51b815260206004820152601e60248201527f496e76616c696420696d706c656d656e746174696f6e206164647265737300006044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe608060405230546000808092368280378136915af43d82803e156020573d90f35b3d90fdfea2646970667358221220a03b18dce0be0b4c9afe58a9eb85c35205e2cf087da098bbf1d23945bf89496064736f6c63430008110033";
const ADDRESS_RESOLVER_ADDRESS = "0x00000E81673606e07fC79CE5F1b3B26957844468";
const DefaultGasLimit = {
    callGasLimit: 800000,
    verificationGasLimit: 1000000,
    preVerificationGas: 100000
};
const ERROR_MESSAGES = {
    ACCOUNT_NOT_DEPLOYED: "Account has not yet been deployed",
    ACCOUNT_ALREADY_DEPLOYED: "Account already deployed",
    NO_NATIVE_TOKEN_BALANCE_DURING_DEPLOY: "Native token balance is not available during deploy",
    SPENDER_REQUIRED: "spender is required for ERC20 mode",
    NO_FEE_QUOTE: "FeeQuote was not provided, please call smartAccount.getTokenFees() to get feeQuote",
    FAILED_FEE_QUOTE_FETCH: "Failed to fetch fee quote",
    CHAIN_NOT_FOUND: "Chain not found",
    NO_RECIPIENT: "Recipient is required",
    NATIVE_TOKEN_WITHDRAWAL_WITHOUT_AMOUNT: "'Amount' is required for withdrawal of native token without using a paymaster",
    MISSING_RPC_URL: "rpcUrl is required for PrivateKeyAccount signer type, please provide it in the config",
    INVALID_SESSION_INDEXES: "Session indexes and transactions must be of the same length and correspond to each other",
    SIGNER_REQUIRED: "Signer is required for creating a smart account",
    UNKNOW_SESSION_ARGUMENTS: "You have not provided the necessary information to find and use a session",
    CHAIN_ID_MISMATCH: "Chain ID does not match the chain ID of the session",
    MISSING_SESSION_ID: "Session ID is missing",
    NO_LEAF_FOUND: "No leaf found for the provided session ID",
    NO_DAN_MODULE_INFO: "No DAN module info found for the provided session ID",
    INVALID_BROWSER_WALLET: "Invalid BrowserWallet provided"
};
const NATIVE_TOKEN_ALIAS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
const ERC20_ABI = [
    "function transfer(address to, uint256 value) external returns (bool)",
    "function transferFrom(address from, address to, uint256 value) external returns (bool)",
    "function approve(address spender, uint256 value) external returns (bool)",
    "function allowance(address owner, address spender) external view returns (uint256)",
    "function balanceOf(address owner) external view returns (uint256)",
    "function decimals() external view returns (uint8)"
]; //# sourceMappingURL=Constants.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/BaseValidationModule.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseValidationModule",
    ()=>BaseValidationModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)");
;
class BaseValidationModule {
    constructor(moduleConfig){
        Object.defineProperty(this, "entryPointAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { entryPointAddress } = moduleConfig;
        this.entryPointAddress = entryPointAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ENTRYPOINT_ADDRESS"];
    }
    setEntryPointAddress(entryPointAddress) {
        this.entryPointAddress = entryPointAddress;
    }
    async signMessageSmartAccountSigner(_message, signer) {
        const message = typeof _message === "string" ? _message : {
            raw: _message
        };
        let signature = await signer.signMessage(message);
        const potentiallyIncorrectV = Number.parseInt(signature.slice(-2), 16);
        if (![
            27,
            28
        ].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = `0x${signature.slice(0, -2) + correctV.toString(16)}`;
        }
        return signature;
    }
} //# sourceMappingURL=BaseValidationModule.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/signers/wallet-client.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WalletClientSigner",
    ()=>WalletClientSigner
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [client] (ecmascript)");
;
class WalletClientSigner {
    constructor(client, signerType){
        Object.defineProperty(this, "signerType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "getAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async ()=>{
                const addresses = await this.inner.getAddresses();
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAddress"])(addresses[0]);
            }
        });
        Object.defineProperty(this, "signMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (message)=>{
                const account = this.inner.account ?? await this.getAddress();
                return this.inner.signMessage({
                    message,
                    account
                });
            }
        });
        Object.defineProperty(this, "signTypedData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (typedData)=>{
                const account = this.inner.account ?? await this.getAddress();
                return this.inner.signTypedData({
                    account,
                    ...typedData
                });
            }
        });
        this.inner = client;
        if (!signerType) {
            throw new Error(`InvalidSignerTypeError: ${signerType}`);
        }
        this.signerType = signerType;
    }
} //# sourceMappingURL=wallet-client.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/EthersSigner.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EthersSigner",
    ()=>EthersSigner,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tslib/tslib.es6.mjs [client] (ecmascript)");
var _EthersSigner_correctSignature;
;
class EthersSigner {
    constructor(inner, signerType){
        Object.defineProperty(this, "signerType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ethers"
        });
        Object.defineProperty(this, "inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _EthersSigner_correctSignature.set(this, (_signature)=>{
            let signature = _signature;
            const potentiallyIncorrectV = Number.parseInt(signature.slice(-2), 16);
            if (![
                27,
                28
            ].includes(potentiallyIncorrectV)) {
                const correctV = potentiallyIncorrectV + 27;
                signature = signature.slice(0, -2) + correctV.toString(16);
            }
            return signature;
        });
        this.inner = inner;
        this.signerType = signerType;
    }
    async getAddress() {
        return await this.inner.getAddress();
    }
    async signMessage(_message) {
        const message = typeof _message === "string" ? _message : _message.raw;
        const signature = await this.inner?.signMessage(message);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["__classPrivateFieldGet"])(this, _EthersSigner_correctSignature, "f").call(this, signature);
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    async signTypedData(_) {
        throw new Error("signTypedData is not supported for Ethers Signer");
    }
}
_EthersSigner_correctSignature = new WeakMap();
const __TURBOPACK__default__export__ = EthersSigner;
 //# sourceMappingURL=EthersSigner.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/convertSigner.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "convertSigner",
    ()=>convertSigner,
    "getSignerAddress",
    ()=>getSignerAddress,
    "isWalletClient",
    ()=>isWalletClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createWalletClient.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/signers/wallet-client.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$EthersSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/EthersSigner.js [client] (ecmascript)");
;
;
;
function isPrivateKeyAccount(signer) {
    return signer.type === "local";
}
function isWalletClient(signer) {
    return signer.transport !== undefined;
}
function isEthersSigner(signer) {
    return signer.provider !== undefined;
}
function isAlchemySigner(signer) {
    return signer?.signerType !== undefined;
}
const convertSigner = async (signer, skipChainIdCalls = false, _rpcUrl)=>{
    let resolvedSmartAccountSigner;
    let rpcUrl = _rpcUrl;
    let chainId = null;
    if (!isAlchemySigner(signer)) {
        if (isEthersSigner(signer)) {
            const ethersSigner = signer;
            if (!skipChainIdCalls) {
                // If chainId not provided, get it from walletClient
                if (!ethersSigner.provider) {
                    throw new Error("Cannot consume an ethers Wallet without a provider");
                }
                const chainIdFromProvider = await ethersSigner.provider.getNetwork();
                if (!chainIdFromProvider?.chainId) {
                    throw new Error("Cannot consume an ethers Wallet without a chainId");
                }
                chainId = Number(chainIdFromProvider.chainId);
            }
            // convert ethers Wallet to alchemy's SmartAccountSigner under the hood
            resolvedSmartAccountSigner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$EthersSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["EthersSigner"](ethersSigner, "ethers");
            // @ts-ignore
            rpcUrl = ethersSigner.provider?.connection?.url ?? undefined;
        } else if (isWalletClient(signer)) {
            const walletClient = signer;
            if (!walletClient.account) {
                throw new Error("Cannot consume a viem wallet without an account");
            }
            if (!skipChainIdCalls) {
                // If chainId not provided, get it from walletClient
                if (!walletClient.chain) {
                    throw new Error("Cannot consume a viem wallet without a chainId");
                }
                chainId = walletClient.chain.id;
            }
            // convert viems walletClient to alchemy's SmartAccountSigner under the hood
            resolvedSmartAccountSigner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WalletClientSigner"](walletClient, "viem");
            rpcUrl = walletClient?.transport?.url ?? undefined;
        } else if (isPrivateKeyAccount(signer)) {
            if (rpcUrl !== null && rpcUrl !== undefined) {
                const walletClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createWalletClient"])({
                    account: signer,
                    transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])(rpcUrl)
                });
                resolvedSmartAccountSigner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WalletClientSigner"](walletClient, "viem");
            } else {
                throw new Error("rpcUrl is required for PrivateKeyAccount signer type, please provide it in the config");
            }
        } else {
            throw new Error("Unsupported signer");
        }
    } else {
        resolvedSmartAccountSigner = signer;
    }
    return {
        signer: resolvedSmartAccountSigner,
        rpcUrl,
        chainId
    };
};
const getSignerAddress = async (signer)=>{
    if (isEthersSigner(signer)) {
        const result = await signer?.getAddress();
        if (result) return result;
        throw new Error("Unsupported signer");
    }
    if (isWalletClient(signer)) {
        const result = signer?.account?.address;
        if (result) return result;
        throw new Error("Unsupported signer");
    }
    if (isPrivateKeyAccount(signer)) {
        const result = signer?.address;
        if (result) return result;
        throw new Error("Unsupported signer");
    }
    if (isAlchemySigner(signer)) {
        const result = signer?.inner?.address;
        if (result) return result;
        throw new Error("Unsupported signer");
    }
    throw new Error("Unsupported signer");
}; //# sourceMappingURL=convertSigner.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/SessionMemoryStorage.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SessionMemoryStorage",
    ()=>SessionMemoryStorage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createWalletClient.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/accounts/privateKeyToAccount.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/signers/wallet-client.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Helper.js [client] (ecmascript)");
;
;
;
;
const memoryStorage = {
    _store: {},
    getItem: (key)=>{
        return memoryStorage._store[key];
    },
    setItem: (key, value)=>{
        memoryStorage._store[key] = value;
    }
};
class SessionMemoryStorage {
    constructor(smartAccountAddress){
        Object.defineProperty(this, "smartAccountAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.smartAccountAddress = smartAccountAddress.toLowerCase();
    }
    validateSearchParam(param) {
        if (param.sessionID || !param.sessionID && param.sessionPublicKey && param.sessionValidationModule) {
            return;
        }
        throw new Error("Either pass sessionId or a combination of sessionPublicKey and sessionValidationModule address.");
    }
    getSessionStore() {
        const data = memoryStorage.getItem(this.getStorageKey("sessions"));
        return data ? JSON.parse(data) : {
            merkleRoot: "",
            leafNodes: []
        };
    }
    getSignerStore() {
        const data = memoryStorage.getItem(this.getStorageKey("signers"));
        return data ? JSON.parse(data) : {};
    }
    getStorageKey(type) {
        return `${this.smartAccountAddress}_${type}`;
    }
    toLowercaseAddress(address) {
        return address.toLowerCase();
    }
    async addSessionData(leaf) {
        const data = this.getSessionStore();
        leaf.sessionValidationModule = this.toLowercaseAddress(leaf.sessionValidationModule);
        leaf.sessionPublicKey = this.toLowercaseAddress(leaf.sessionPublicKey);
        data.leafNodes.push(leaf);
        memoryStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async getSessionData(param) {
        this.validateSearchParam(param);
        const sessions = this.getSessionStore().leafNodes;
        const session = sessions.find((s)=>{
            if (param.sessionID) {
                return s.sessionID === param.sessionID && (!param.status || s.status === param.status);
            }
            if (param.sessionPublicKey && param.sessionValidationModule) {
                return s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) && s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule) && (!param.status || s.status === param.status);
            }
            return undefined;
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        return session;
    }
    async updateSessionStatus(param, status) {
        this.validateSearchParam(param);
        const data = this.getSessionStore();
        const session = data.leafNodes.find((s)=>{
            if (param.sessionID) {
                return s.sessionID === param.sessionID;
            }
            if (param.sessionPublicKey && param.sessionValidationModule) {
                return s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) && s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule);
            }
            return undefined;
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        session.status = status;
        memoryStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async clearPendingSessions() {
        const data = this.getSessionStore();
        data.leafNodes = data.leafNodes.filter((s)=>s.status !== "PENDING");
        memoryStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async addSigner(signerData, chain) {
        const signers = this.getSignerStore();
        const signer = signerData ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getRandomSigner"])();
        const accountSigner = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["privateKeyToAccount"])(signer.pvKey);
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createWalletClient"])({
            account: accountSigner,
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])()
        });
        const walletClientSigner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WalletClientSigner"](client, "json-rpc" // signerType
        );
        signers[this.toLowercaseAddress(accountSigner.address)] = signer;
        memoryStorage.setItem(this.getStorageKey("signers"), JSON.stringify(signers));
        return walletClientSigner;
    }
    async getSignerByKey(sessionPublicKey, chain) {
        const signers = this.getSignerStore();
        const signerData = signers[this.toLowercaseAddress(sessionPublicKey)];
        if (!signerData) {
            throw new Error("Signer not found.");
        }
        const account = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["privateKeyToAccount"])(signerData.pvKey);
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createWalletClient"])({
            account,
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])()
        });
        const signer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WalletClientSigner"](client, "viem");
        return signer;
    }
    async revokeSessions(sessionIDs) {
        const data = this.getSessionStore();
        let newLeafNodes = [];
        for (const sessionID of sessionIDs){
            newLeafNodes = data.leafNodes.filter((s)=>{
                if (sessionID) {
                    return s.sessionID !== sessionID;
                }
                return undefined;
            });
        }
        return newLeafNodes;
    }
    async getSignerBySession(param, chain) {
        const session = await this.getSessionData(param);
        return this.getSignerByKey(session.sessionPublicKey, chain);
    }
    async getAllSessionData(param) {
        const sessions = this.getSessionStore().leafNodes;
        if (!param || !param.status) {
            return sessions;
        }
        return sessions.filter((s)=>s.status === param.status);
    }
    async getMerkleRoot() {
        return this.getSessionStore().merkleRoot;
    }
    setMerkleRoot(merkleRoot) {
        const data = this.getSessionStore();
        data.merkleRoot = merkleRoot;
        memoryStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
        return Promise.resolve();
    }
} //# sourceMappingURL=SessionMemoryStorage.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/utils.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSessionKeyEOA",
    ()=>createSessionKeyEOA,
    "getDefaultStorageClient",
    ()=>getDefaultStorageClient,
    "inNodeBackend",
    ()=>inNodeBackend,
    "inTesting",
    ()=>inTesting
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionLocalStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/SessionLocalStorage.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionMemoryStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/SessionMemoryStorage.js [client] (ecmascript)");
;
;
const createSessionKeyEOA = async (smartAccount, chain, _sessionStorageClient)=>{
    const userAccountAddress = await smartAccount.getAddress();
    const sessionStorageClient = _sessionStorageClient ?? getDefaultStorageClient(userAccountAddress);
    const newSigner = await sessionStorageClient.addSigner(undefined, chain);
    const sessionKeyAddress = await newSigner.getAddress();
    return {
        sessionKeyAddress,
        signer: newSigner,
        sessionStorageClient
    };
};
const inTesting = ()=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]?.env?.TESTING?.toString() === "true";
    } catch (e) {
        return false;
    }
};
const inNodeBackend = ()=>{
    try {
        return typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] === "object" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"]?.release?.name === "node";
    } catch (e) {
        return false;
    }
};
const getDefaultStorageClient = (address)=>{
    if (inTesting()) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionMemoryStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionMemoryStorage"](address);
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionLocalStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["supportsLocalStorage"]) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionLocalStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionLocalStorage"](address);
    }
    if (inNodeBackend()) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionMemoryStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionMemoryStorage"](address); // Fallback to memory storage
    }
    throw new Error("No session storage client available");
}; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Helper.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "didProvideFullSession",
    ()=>didProvideFullSession,
    "getRandomSigner",
    ()=>getRandomSigner,
    "getUserOpHash",
    ()=>getUserOpHash,
    "hexToUint8Array",
    ()=>hexToUint8Array,
    "parseChain",
    ()=>parseChain,
    "resumeSession",
    ()=>resumeSession
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/isAddress.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$generatePrivateKey$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/accounts/generatePrivateKey.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/accounts/privateKeyToAccount.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/getChain.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/utils.js [client] (ecmascript)");
;
;
;
;
function packUserOp(op, forSignature = true) {
    if (!op.initCode || !op.callData || !op.paymasterAndData) throw new Error("Missing userOp properties");
    if (forSignature) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("address, uint256, bytes32, bytes32, uint256, uint256, uint256, uint256, uint256, bytes32"), [
            op.sender,
            BigInt(op.nonce),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(op.initCode),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(op.callData),
            BigInt(op.callGasLimit),
            BigInt(op.verificationGasLimit),
            BigInt(op.preVerificationGas),
            BigInt(op.maxFeePerGas),
            BigInt(op.maxPriorityFeePerGas),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(op.paymasterAndData)
        ]);
    }
    // for the purpose of calculating gas cost encode also signature (and no keccak of bytes)
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("address, uint256, bytes, bytes, uint256, uint256, uint256, uint256, uint256, bytes, bytes"), [
        op.sender,
        BigInt(op.nonce),
        op.initCode,
        op.callData,
        BigInt(op.callGasLimit),
        BigInt(op.verificationGasLimit),
        BigInt(op.preVerificationGas),
        BigInt(op.maxFeePerGas),
        BigInt(op.maxPriorityFeePerGas),
        op.paymasterAndData,
        op.signature
    ]);
}
const getUserOpHash = (userOp, entryPointAddress, chainId)=>{
    const userOpHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(packUserOp(userOp, true));
    const enc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("bytes32, address, uint256"), [
        userOpHash,
        entryPointAddress,
        BigInt(chainId)
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(enc);
};
const getRandomSigner = ()=>{
    const pkey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$generatePrivateKey$2e$js__$5b$client$5d$__$28$ecmascript$29$__["generatePrivateKey"])();
    const account = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["privateKeyToAccount"])(pkey);
    return {
        pvKey: pkey,
        pbKey: account.address
    };
};
const parseChain = (chainInfo)=>{
    if (typeof chainInfo === "number") return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(chainInfo);
    return chainInfo;
};
const didProvideFullSession = (searchParam)=>!!searchParam?.sessionIDInfo?.length;
const resumeSession = async (searchParam)=>{
    const providedFullSession = didProvideFullSession(searchParam);
    const providedStorageClient = !!searchParam.smartAccountAddress?.length;
    const providedSmartAccountAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isAddress"])(searchParam);
    if (providedFullSession) {
        const session = searchParam;
        return session;
    }
    if (providedStorageClient) {
        const sessionStorageClient = searchParam;
        const leafArray = await sessionStorageClient.getAllSessionData();
        const sessionIDInfo = leafArray.map(({ sessionID })=>sessionID);
        const session = {
            sessionIDInfo,
            sessionStorageClient
        };
        return session;
    }
    if (providedSmartAccountAddress) {
        const smartAccountAddress = searchParam;
        // Use the default session storage client
        const sessionStorageClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDefaultStorageClient"])(smartAccountAddress);
        const leafArray = await sessionStorageClient.getAllSessionData();
        const sessionIDInfo = leafArray.map(({ sessionID })=>sessionID);
        const session = {
            sessionIDInfo,
            sessionStorageClient
        };
        return session;
    }
    throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].UNKNOW_SESSION_ARGUMENTS);
};
const hexToUint8Array = (hex)=>{
    if (hex.length % 2 !== 0) {
        throw new Error("Hex string must have an even number of characters");
    }
    const array = new Uint8Array(hex.length / 2);
    for(let i = 0; i < hex.length; i += 2){
        array[i / 2] = Number.parseInt(hex.substr(i, 2), 16);
    }
    return array;
}; //# sourceMappingURL=Helper.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/SessionLocalStorage.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SessionLocalStorage",
    ()=>SessionLocalStorage,
    "inBrowser",
    ()=>inBrowser,
    "supportsLocalStorage",
    ()=>supportsLocalStorage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createWalletClient.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/accounts/privateKeyToAccount.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/signers/wallet-client.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Helper.js [client] (ecmascript)");
;
;
;
;
const inBrowser = typeof window !== "undefined";
const supportsLocalStorage = // @ts-ignore: LocalStorage is not available in node
inBrowser && typeof window.localStorage !== "undefined";
class SessionLocalStorage {
    constructor(smartAccountAddress){
        Object.defineProperty(this, "smartAccountAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.smartAccountAddress = smartAccountAddress.toLowerCase();
    }
    validateSearchParam(param) {
        if (param.sessionID || !param.sessionID && param.sessionPublicKey && param.sessionValidationModule) {
            return;
        }
        throw new Error("Either pass sessionId or a combination of sessionPublicKey and sessionValidationModule address.");
    }
    getSessionStore() {
        // @ts-ignore: LocalStorage is not available in node
        const data = localStorage.getItem(this.getStorageKey("sessions"));
        return data ? JSON.parse(data) : {
            merkleRoot: "",
            leafNodes: []
        };
    }
    getSignerStore() {
        // @ts-ignore: LocalStorage is not available in node
        const data = localStorage.getItem(this.getStorageKey("signers"));
        return data ? JSON.parse(data) : {};
    }
    getStorageKey(type) {
        return `${this.smartAccountAddress}_${type}`;
    }
    toLowercaseAddress(address) {
        return address.toLowerCase();
    }
    async addSessionData(leaf) {
        const data = this.getSessionStore();
        leaf.sessionValidationModule = this.toLowercaseAddress(leaf.sessionValidationModule);
        leaf.sessionPublicKey = this.toLowercaseAddress(leaf.sessionPublicKey);
        data.leafNodes.push(leaf);
        // @ts-ignore: LocalStorage is not available in node
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async getSessionData(param) {
        this.validateSearchParam(param);
        const sessions = this.getSessionStore().leafNodes;
        const session = sessions.find((s)=>{
            if (param.sessionID) {
                return s.sessionID === param.sessionID && (!param.status || s.status === param.status);
            }
            if (param.sessionPublicKey && param.sessionValidationModule) {
                return s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) && s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule) && (!param.status || s.status === param.status);
            }
            return undefined;
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        return session;
    }
    async updateSessionStatus(param, status) {
        this.validateSearchParam(param);
        const data = this.getSessionStore();
        const session = data.leafNodes.find((s)=>{
            if (param.sessionID) {
                return s.sessionID === param.sessionID;
            }
            if (param.sessionPublicKey && param.sessionValidationModule) {
                return s.sessionPublicKey === this.toLowercaseAddress(param.sessionPublicKey) && s.sessionValidationModule === this.toLowercaseAddress(param.sessionValidationModule);
            }
            return undefined;
        });
        if (!session) {
            throw new Error("Session not found.");
        }
        session.status = status;
        // @ts-ignore: LocalStorage is not available in node
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async clearPendingSessions() {
        const data = this.getSessionStore();
        data.leafNodes = data.leafNodes.filter((s)=>s.status !== "PENDING");
        // @ts-ignore: LocalStorage is not available in node
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
    }
    async addSigner(signerData, chain) {
        const signers = this.getSignerStore();
        const signer = signerData ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getRandomSigner"])();
        const accountSigner = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["privateKeyToAccount"])(signer.pvKey);
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createWalletClient"])({
            account: accountSigner,
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])()
        });
        const walletClientSigner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WalletClientSigner"](client, "json-rpc" // signerType
        );
        signers[this.toLowercaseAddress(accountSigner.address)] = signer;
        // @ts-ignore: LocalStorage is not available in node
        localStorage.setItem(this.getStorageKey("signers"), JSON.stringify(signers));
        return walletClientSigner;
    }
    async getSignerByKey(sessionPublicKey, chain) {
        const signers = this.getSignerStore();
        const signerData = signers[this.toLowercaseAddress(sessionPublicKey)];
        if (!signerData) {
            throw new Error("Signer not found.");
        }
        const account = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$privateKeyToAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["privateKeyToAccount"])(signerData.pvKey);
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createWalletClient"])({
            account,
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])()
        });
        const signer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$signers$2f$wallet$2d$client$2e$js__$5b$client$5d$__$28$ecmascript$29$__["WalletClientSigner"](client, "viem");
        return signer;
    }
    async getSignerBySession(param, chain) {
        const session = await this.getSessionData(param);
        return this.getSignerByKey(session.sessionPublicKey, chain);
    }
    async getAllSessionData(param) {
        const sessions = this.getSessionStore().leafNodes;
        if (!param || !param.status) {
            return sessions;
        }
        return sessions.filter((s)=>s.status === param.status);
    }
    async revokeSessions(sessionIDs) {
        const data = this.getSessionStore();
        let newLeafNodes = [];
        for (const sessionID of sessionIDs){
            newLeafNodes = data.leafNodes.filter((s)=>{
                if (sessionID) {
                    return s.sessionID !== sessionID;
                }
                return undefined;
            });
        }
        return newLeafNodes;
    }
    async getMerkleRoot() {
        return this.getSessionStore().merkleRoot;
    }
    setMerkleRoot(merkleRoot) {
        const data = this.getSessionStore();
        data.merkleRoot = merkleRoot;
        // @ts-ignore: LocalStorage is not available in node
        localStorage.setItem(this.getStorageKey("sessions"), JSON.stringify(data));
        return Promise.resolve();
    }
} //# sourceMappingURL=SessionLocalStorage.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Constants.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BATCHED_SESSION_ROUTER_MODULE_ADDRESSES_BY_VERSION",
    ()=>BATCHED_SESSION_ROUTER_MODULE_ADDRESSES_BY_VERSION,
    "DAN_BACKEND_URL",
    ()=>DAN_BACKEND_URL,
    "DEFAULT_ABI_SVM_MODULE",
    ()=>DEFAULT_ABI_SVM_MODULE,
    "DEFAULT_BATCHED_SESSION_ROUTER_MODULE",
    ()=>DEFAULT_BATCHED_SESSION_ROUTER_MODULE,
    "DEFAULT_ECDSA_OWNERSHIP_MODULE",
    ()=>DEFAULT_ECDSA_OWNERSHIP_MODULE,
    "DEFAULT_ERC20_MODULE",
    ()=>DEFAULT_ERC20_MODULE,
    "DEFAULT_MODULE_VERSION",
    ()=>DEFAULT_MODULE_VERSION,
    "DEFAULT_MULTICHAIN_MODULE",
    ()=>DEFAULT_MULTICHAIN_MODULE,
    "DEFAULT_SESSION_KEY_MANAGER_MODULE",
    ()=>DEFAULT_SESSION_KEY_MANAGER_MODULE,
    "ECDSA_OWNERSHIP_MODULE_ADDRESSES_BY_VERSION",
    ()=>ECDSA_OWNERSHIP_MODULE_ADDRESSES_BY_VERSION,
    "MULTICHAIN_VALIDATION_MODULE_ADDRESSES_BY_VERSION",
    ()=>MULTICHAIN_VALIDATION_MODULE_ADDRESSES_BY_VERSION,
    "SESSION_MANAGER_MODULE_ADDRESSES_BY_VERSION",
    ()=>SESSION_MANAGER_MODULE_ADDRESSES_BY_VERSION
]);
const DEFAULT_MODULE_VERSION = "V1_0_0";
const DEFAULT_ECDSA_OWNERSHIP_MODULE = "0x0000001c5b32F37F5beA87BDD5374eB2aC54eA8e";
const ECDSA_OWNERSHIP_MODULE_ADDRESSES_BY_VERSION = {
    V1_0_0: "0x0000001c5b32F37F5beA87BDD5374eB2aC54eA8e"
};
const DEFAULT_SESSION_KEY_MANAGER_MODULE = "0x000002FbFfedd9B33F4E7156F2DE8D48945E7489";
const SESSION_MANAGER_MODULE_ADDRESSES_BY_VERSION = {
    V1_0_0: "0x000000456b395c4e107e0302553B90D1eF4a32e9",
    V1_0_1: "0x000002FbFfedd9B33F4E7156F2DE8D48945E7489"
};
const DEFAULT_BATCHED_SESSION_ROUTER_MODULE = "0x00000D09967410f8C76752A104c9848b57ebba55";
const BATCHED_SESSION_ROUTER_MODULE_ADDRESSES_BY_VERSION = {
    V1_0_0: "0x00000D09967410f8C76752A104c9848b57ebba55"
};
const DEFAULT_ERC20_MODULE = "0x000000D50C68705bd6897B2d17c7de32FB519fDA";
const DEFAULT_MULTICHAIN_MODULE = "0x000000824dc138db84FD9109fc154bdad332Aa8E";
const MULTICHAIN_VALIDATION_MODULE_ADDRESSES_BY_VERSION = {
    V1_0_0: "0x000000824dc138db84FD9109fc154bdad332Aa8E"
};
const DEFAULT_ABI_SVM_MODULE = "0x000006bC2eCdAe38113929293d241Cf252D91861";
const DAN_BACKEND_URL = "wss://dan.staging.biconomy.io/v1"; //# sourceMappingURL=Constants.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Types.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StorageType",
    ()=>StorageType
]);
var StorageType;
(function(StorageType) {
    StorageType[StorageType["LOCAL_STORAGE"] = 0] = "LOCAL_STORAGE";
    StorageType[StorageType["MEMORY_STORAGE"] = 1] = "MEMORY_STORAGE";
})(StorageType || (StorageType = {})); //# sourceMappingURL=Types.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Uid.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// small uid generator, hex: 0-9, a-f (10 chars)
__turbopack_context__.s([
    "generateRandomHex",
    ()=>generateRandomHex
]);
const generateRandomHex = ()=>{
    const hexChars = "0123456789abcdef";
    let result = "";
    for(let i = 0; i < 10; i++){
        const randomIndex = Math.floor(Math.random() * hexChars.length);
        result += hexChars[randomIndex];
    }
    return result;
}; //# sourceMappingURL=Uid.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/SessionKeyManagerModule.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SessionKeyManagerModule",
    ()=>SessionKeyManagerModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merkletreejs$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/merkletreejs/dist/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeFunctionData.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/pad.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toBytes.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/convertSigner.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/BaseValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionLocalStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/SessionLocalStorage.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionMemoryStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/SessionMemoryStorage.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Types.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Uid.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
class SessionKeyManagerModule extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseValidationModule"] {
    /**
     * This constructor is private. Use the static create method to instantiate SessionKeyManagerModule
     * @param moduleConfig The configuration for the module
     * @returns An instance of SessionKeyManagerModule
     */ constructor(moduleConfig){
        super(moduleConfig);
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "V1_0_0"
        });
        Object.defineProperty(this, "moduleAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "merkleTree", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sessionStorageClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mockEcdsaSessionKeySig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b"
        });
        /**
         * Method to create session data for any module. The session data is used to create a leaf in the merkle tree
         * @param leavesData The data of one or more leaves to be used to create session data
         * @returns The session data
         */ Object.defineProperty(this, "createSessionData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (leavesData)=>{
                const sessionKeyManagerModuleABI = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbi"])([
                    "function setMerkleRoot(bytes32 _merkleRoot)"
                ]);
                const leavesToAdd = [];
                const sessionIDInfo = [];
                for (const leafData of leavesData){
                    const leafDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(leafData.validUntil), {
                            size: 6
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(leafData.validAfter), {
                            size: 6
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(leafData.sessionValidationModule, {
                            size: 20
                        }),
                        leafData.sessionKeyData
                    ]);
                    const generatedSessionId = leafData.preferredSessionId ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Uid$2e$js__$5b$client$5d$__$28$ecmascript$29$__["generateRandomHex"])();
                    // TODO: verify this, might not be buffer
                    leavesToAdd.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leafDataHex));
                    sessionIDInfo.push(generatedSessionId);
                    const sessionLeafNode = {
                        ...leafData,
                        sessionID: generatedSessionId,
                        status: "PENDING"
                    };
                    await this.sessionStorageClient.addSessionData(sessionLeafNode);
                }
                this.merkleTree.addLeaves(leavesToAdd);
                const leaves = this.merkleTree.getLeaves();
                const newMerkleTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merkletreejs$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MerkleTree"](leaves, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"], {
                    sortPairs: true,
                    hashLeaves: false
                });
                this.merkleTree = newMerkleTree;
                const setMerkleRootData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
                    abi: sessionKeyManagerModuleABI,
                    functionName: "setMerkleRoot",
                    args: [
                        this.merkleTree.getHexRoot()
                    ]
                });
                await this.sessionStorageClient.setMerkleRoot(this.merkleTree.getHexRoot());
                return {
                    data: setMerkleRootData,
                    sessionIDInfo: sessionIDInfo
                };
            }
        });
    }
    /**
     * Asynchronously creates and initializes an instance of SessionKeyManagerModule
     * @param moduleConfig The configuration for the module
     * @returns A Promise that resolves to an instance of SessionKeyManagerModule
     */ static async create(moduleConfig) {
        // TODO: (Joe) stop doing things in a 'create' call after the instance has been created
        const instance = new SessionKeyManagerModule(moduleConfig);
        if (moduleConfig.moduleAddress) {
            instance.moduleAddress = moduleConfig.moduleAddress;
        } else if (moduleConfig.version) {
            const moduleAddr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SESSION_MANAGER_MODULE_ADDRESSES_BY_VERSION"][moduleConfig.version];
            if (!moduleAddr) {
                throw new Error(`Invalid version ${moduleConfig.version}`);
            }
            instance.moduleAddress = moduleAddr;
            instance.version = moduleConfig.version;
        } else {
            instance.moduleAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"];
        // Note: in this case Version remains the default one
        }
        if (moduleConfig.sessionStorageClient) {
            instance.sessionStorageClient = moduleConfig.sessionStorageClient;
        } else {
            switch(moduleConfig.storageType){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["StorageType"].MEMORY_STORAGE:
                    instance.sessionStorageClient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionMemoryStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionMemoryStorage"](moduleConfig.smartAccountAddress);
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["StorageType"].LOCAL_STORAGE:
                    instance.sessionStorageClient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionLocalStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionLocalStorage"](moduleConfig.smartAccountAddress);
                    break;
                default:
                    instance.sessionStorageClient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$SessionLocalStorage$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionLocalStorage"](moduleConfig.smartAccountAddress);
            }
        }
        const existingSessionData = await instance.sessionStorageClient.getAllSessionData();
        const existingSessionDataLeafs = existingSessionData.map((sessionData)=>{
            const leafDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionData.validUntil), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionData.validAfter), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(sessionData.sessionValidationModule, {
                    size: 20
                }),
                sessionData.sessionKeyData
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leafDataHex);
        });
        instance.merkleTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merkletreejs$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MerkleTree"](existingSessionDataLeafs, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"], {
            sortPairs: true,
            hashLeaves: false
        });
        return instance;
    }
    /**
     * Revokes specified sessions by generating a new Merkle root and updating the session statuses to "REVOKED".
     *
     * This method performs the following steps:
     * 1. Calls `revokeSessions` on the session storage client to get new leaf nodes for the sessions to be revoked.
     * 2. Constructs new leaf data from the session details, including validity periods and session validation module.
     * 3. Hashes the leaf data using `keccak256` and adds them to the Merkle tree.
     * 4. Creates a new Merkle tree with the updated leaves and updates the internal Merkle tree reference.
     * 5. Sets the new Merkle root in the session storage.
     * 6. Updates the status of each specified session to "REVOKED" in the session storage.
     *
     * @param sessionIDs - An array of session IDs to be revoked.
     * @returns A promise that resolves to the new Merkle root as a hexadecimal string.
     */ async revokeSessions(sessionIDs) {
        const newLeafs = await this.sessionStorageClient.revokeSessions(sessionIDs);
        const leavesToAdd = [];
        for (const leaf of newLeafs){
            const leafDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(leaf.validUntil), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(leaf.validAfter), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(leaf.sessionValidationModule, {
                    size: 20
                }),
                leaf.sessionKeyData
            ]);
            leavesToAdd.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leafDataHex));
        }
        this.merkleTree.addLeaves(leavesToAdd);
        const leaves = this.merkleTree.getLeaves();
        const newMerkleTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merkletreejs$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MerkleTree"](leaves, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"], {
            sortPairs: true,
            hashLeaves: false
        });
        this.merkleTree = newMerkleTree;
        await this.sessionStorageClient.setMerkleRoot(this.merkleTree.getHexRoot());
        for (const sessionID of sessionIDs){
            this.sessionStorageClient.updateSessionStatus({
                sessionID
            }, "REVOKED");
        }
        return newMerkleTree.getHexRoot();
    }
    /**
     * This method is used to sign the user operation using the session signer
     * @param userOp The user operation to be signed
     * @param sessionSigner The signer to be used to sign the user operation
     * @returns The signature of the user operation
     */ async signUserOpHash(userOpHash, params) {
        if (!params?.sessionSigner) {
            throw new Error("Session signer is not provided.");
        }
        const { signer: sessionSigner } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(params.sessionSigner, false);
        // Use the sessionSigner to sign the user operation
        const signature = await sessionSigner.signMessage({
            raw: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBytes"])(userOpHash)
        });
        const sessionSignerData = await this.getLeafInfo(params);
        const leafDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validUntil), {
                size: 6
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validAfter), {
                size: 6
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(sessionSignerData.sessionValidationModule, {
                size: 20
            }),
            sessionSignerData.sessionKeyData
        ]);
        // Generate the padded signature with (validUntil,validAfter,sessionVerificationModuleAddress,validationData,merkleProof,signature)
        let paddedSignature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("uint48, uint48, address, bytes, bytes32[], bytes"), [
            sessionSignerData.validUntil,
            sessionSignerData.validAfter,
            sessionSignerData.sessionValidationModule,
            sessionSignerData.sessionKeyData,
            this.merkleTree.getHexProof((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leafDataHex)),
            signature
        ]);
        if (params?.additionalSessionData) {
            paddedSignature += params.additionalSessionData;
        }
        return paddedSignature;
    }
    async getLeafInfo(params) {
        if (!params?.sessionSigner) {
            throw new Error("Session signer is not provided.");
        }
        const { signer: sessionSigner } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(params.sessionSigner, false);
        // biome-ignore lint/suspicious/noImplicitAnyLet: <explanation>
        let sessionSignerData;
        if (params?.sessionID) {
            sessionSignerData = await this.sessionStorageClient.getSessionData({
                sessionID: params.sessionID
            });
        } else if (params?.sessionValidationModule) {
            sessionSignerData = await this.sessionStorageClient.getSessionData({
                sessionValidationModule: params.sessionValidationModule,
                sessionPublicKey: await sessionSigner.getAddress()
            });
        } else {
            throw new Error("sessionID or sessionValidationModule should be provided.");
        }
        return sessionSignerData;
    }
    /**
     * Update the session data pending state to active
     * @param param The search param to find the session data
     * @param status The status to be updated
     * @returns
     */ async updateSessionStatus(param, status) {
        this.sessionStorageClient.updateSessionStatus(param, status);
    }
    /**
     * @remarks This method is used to clear all the pending sessions
     * @returns
     */ async clearPendingSessions() {
        this.sessionStorageClient.clearPendingSessions();
    }
    /**
     * @returns SessionKeyManagerModule address
     */ getAddress() {
        return this.moduleAddress;
    }
    /**
     * @remarks This is the version of the module contract
     */ async getSigner() {
        throw new Error("Method not implemented.");
    }
    /**
     * @remarks This is the dummy signature for the module, used in buildUserOp for bundler estimation
     * @returns Dummy signature
     */ async getDummySignature(params) {
        if (!params) {
            throw new Error("Session signer is not provided.");
        }
        const sessionSignerData = await this.getLeafInfo(params);
        const leafDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validUntil), {
                size: 6
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validAfter), {
                size: 6
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(sessionSignerData.sessionValidationModule, {
                size: 20
            }),
            sessionSignerData.sessionKeyData
        ]);
        // Generate the padded signature with (validUntil,validAfter,sessionVerificationModuleAddress,validationData,merkleProof,signature)
        let paddedSignature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("uint48, uint48, address, bytes, bytes32[], bytes"), [
            sessionSignerData.validUntil,
            sessionSignerData.validAfter,
            sessionSignerData.sessionValidationModule,
            sessionSignerData.sessionKeyData,
            this.merkleTree.getHexProof((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leafDataHex)),
            this.mockEcdsaSessionKeySig
        ]);
        if (params?.additionalSessionData) {
            paddedSignature += params.additionalSessionData;
        }
        const dummySig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])([
            "bytes, address"
        ]), [
            paddedSignature,
            this.getAddress()
        ]);
        return dummySig;
    }
    /**
     * @remarks Other modules may need additional attributes to build init data
     */ async getInitData() {
        throw new Error("Method not implemented.");
    }
    /**
     * @remarks This Module dont have knowledge of signer. So, this method is not implemented
     */ async signMessage(_message) {
        throw new Error("Method not implemented.");
    }
} //# sourceMappingURL=SessionKeyManagerModule.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/BatchedSessionRouterModule.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BatchedSessionRouterModule",
    ()=>BatchedSessionRouterModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/pad.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toBytes.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/convertSigner.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/BaseValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$SessionKeyManagerModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/SessionKeyManagerModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Constants.js [client] (ecmascript)");
;
;
;
;
;
class BatchedSessionRouterModule extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseValidationModule"] {
    /**
     * This constructor is private. Use the static create method to instantiate SessionKeyManagerModule
     * @param moduleConfig The configuration for the module
     * @returns An instance of SessionKeyManagerModule
     */ constructor(moduleConfig){
        super(moduleConfig);
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "V1_0_0"
        });
        Object.defineProperty(this, "moduleAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sessionManagerModuleAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sessionKeyManagerModule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mockEcdsaSessionKeySig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b"
        });
        /**
         * Method to create session data for any module. The session data is used to create a leaf in the merkle tree
         * @param leavesData The data of one or more leaves to be used to create session data
         * @returns The session data
         */ Object.defineProperty(this, "createSessionData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (leavesData)=>{
                return this.sessionKeyManagerModule.createSessionData(leavesData);
            }
        });
    }
    /**
     * Asynchronously creates and initializes an instance of SessionKeyManagerModule
     * @param moduleConfig The configuration for the module
     * @returns A Promise that resolves to an instance of SessionKeyManagerModule
     */ static async create(moduleConfig) {
        const instance = new BatchedSessionRouterModule(moduleConfig);
        if (moduleConfig.moduleAddress) {
            instance.moduleAddress = moduleConfig.moduleAddress;
        } else if (moduleConfig.version) {
            const moduleAddr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BATCHED_SESSION_ROUTER_MODULE_ADDRESSES_BY_VERSION"][moduleConfig.version];
            if (!moduleAddr) {
                throw new Error(`Invalid version ${moduleConfig.version}`);
            }
            instance.moduleAddress = moduleAddr;
            instance.version = moduleConfig.version;
        } else {
            instance.moduleAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_BATCHED_SESSION_ROUTER_MODULE"];
        // Note: in this case Version remains the default one
        }
        instance.sessionManagerModuleAddress = moduleConfig.sessionManagerModuleAddress ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"];
        if (!moduleConfig.sessionKeyManagerModule) {
            // generate sessionModule
            const sessionModule = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$SessionKeyManagerModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionKeyManagerModule"].create({
                moduleAddress: instance.sessionManagerModuleAddress,
                smartAccountAddress: moduleConfig.smartAccountAddress,
                storageType: moduleConfig.storageType
            });
            instance.sessionKeyManagerModule = sessionModule;
        } else {
            instance.sessionKeyManagerModule = moduleConfig.sessionKeyManagerModule;
            instance.sessionManagerModuleAddress = moduleConfig.sessionKeyManagerModule.getAddress();
        }
        return instance;
    }
    /**
     * This method is used to sign the user operation using the session signer
     * @param userOp The user operation to be signed
     * @param sessionParams Information about all the sessions to be used to sign the user operation which has a batch execution
     * @returns The signature of the user operation
     */ async signUserOpHash(userOpHash, params) {
        const sessionParams = params?.batchSessionParams;
        if (!sessionParams || sessionParams.length === 0) {
            throw new Error("Session parameters are not provided");
        }
        const sessionDataTupleArray = [];
        // signer must be the same for all the sessions
        const { signer: sessionSigner } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(sessionParams[0].sessionSigner, false);
        const signature = await sessionSigner.signMessage({
            raw: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBytes"])(userOpHash)
        });
        for (const sessionParam of sessionParams){
            if (!sessionParam.sessionSigner) {
                throw new Error("Session signer is not provided.");
            }
            if (!sessionParam.sessionID && !sessionParam.sessionValidationModule) {
                throw new Error("sessionID or sessionValidationModule should be provided.");
            }
            const sessionSignerData = await this.sessionKeyManagerModule.sessionStorageClient.getSessionData(sessionParam.sessionID ? {
                sessionID: sessionParam.sessionID
            } : {
                sessionValidationModule: sessionParam.sessionValidationModule,
                sessionPublicKey: await sessionSigner.getAddress()
            });
            const leafDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validUntil), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validAfter), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(sessionSignerData.sessionValidationModule, {
                    size: 20
                }),
                sessionSignerData.sessionKeyData
            ]);
            const proof = this.sessionKeyManagerModule.merkleTree.getHexProof((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leafDataHex));
            const sessionDataTuple = [
                sessionSignerData.validUntil,
                sessionSignerData.validAfter,
                sessionSignerData.sessionValidationModule,
                sessionSignerData.sessionKeyData,
                proof,
                sessionParam.additionalSessionData ?? "0x"
            ];
            sessionDataTupleArray.push(sessionDataTuple);
        }
        // Generate the padded signature
        const abiParameters = [
            {
                type: "address"
            },
            {
                type: "tuple[]",
                components: [
                    {
                        type: "uint48"
                    },
                    {
                        type: "uint48"
                    },
                    {
                        type: "address"
                    },
                    {
                        type: "bytes"
                    },
                    {
                        type: "bytes32[]"
                    },
                    {
                        type: "bytes"
                    }
                ]
            },
            {
                type: "bytes"
            }
        ];
        const paddedSignature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])(abiParameters, [
            this.getSessionKeyManagerAddress(),
            sessionDataTupleArray,
            signature
        ]);
        return paddedSignature;
    }
    /**
     * Update the session data pending state to active
     * @param param The search param to find the session data
     * @param status The status to be updated
     * @returns
     */ async updateSessionStatus(param, status) {
        this.sessionKeyManagerModule.sessionStorageClient.updateSessionStatus(param, status);
    }
    /**
     * @remarks This method is used to clear all the pending sessions
     * @returns
     */ async clearPendingSessions() {
        this.sessionKeyManagerModule.sessionStorageClient.clearPendingSessions();
    }
    /**
     * @returns SessionKeyManagerModule address
     */ getAddress() {
        return this.moduleAddress;
    }
    /**
     * @returns SessionKeyManagerModule address
     */ getSessionKeyManagerAddress() {
        return this.sessionManagerModuleAddress;
    }
    /**
     * @remarks This is the version of the module contract
     */ async getSigner() {
        throw new Error("Method not implemented.");
    }
    /**
     * @remarks This is the dummy signature for the module, used in buildUserOp for bundler estimation
     * @returns Dummy signature
     */ async getDummySignature(params) {
        const sessionParams = params?.batchSessionParams;
        if (!sessionParams || sessionParams.length === 0) {
            throw new Error("Session parameters are not provided");
        }
        const sessionDataTupleArray = [];
        // signer must be the same for all the sessions
        const { signer: sessionSigner } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(sessionParams[0].sessionSigner, false);
        for (const sessionParam of sessionParams){
            if (!sessionParam.sessionSigner) {
                throw new Error("Session signer is not provided.");
            }
            if (!sessionParam.sessionID && !sessionParam.sessionValidationModule) {
                throw new Error("sessionID or sessionValidationModule should be provided.");
            }
            const sessionSignerData = await this.sessionKeyManagerModule.sessionStorageClient.getSessionData(sessionParam.sessionID ? {
                sessionID: sessionParam.sessionID
            } : {
                sessionValidationModule: sessionParam.sessionValidationModule,
                sessionPublicKey: await sessionSigner.getAddress()
            });
            const leafDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validUntil), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(sessionSignerData.validAfter), {
                    size: 6
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(sessionSignerData.sessionValidationModule, {
                    size: 20
                }),
                sessionSignerData.sessionKeyData
            ]);
            const proof = this.sessionKeyManagerModule.merkleTree.getHexProof((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leafDataHex));
            const sessionDataTuple = [
                BigInt(sessionSignerData.validUntil),
                BigInt(sessionSignerData.validAfter),
                sessionSignerData.sessionValidationModule,
                sessionSignerData.sessionKeyData,
                proof,
                sessionParam.additionalSessionData ?? "0x"
            ];
            sessionDataTupleArray.push(sessionDataTuple);
        }
        // Generate the padded signature
        const abiParameters = [
            {
                type: "address"
            },
            {
                type: "tuple[]",
                components: [
                    {
                        type: "uint48"
                    },
                    {
                        type: "uint48"
                    },
                    {
                        type: "address"
                    },
                    {
                        type: "bytes"
                    },
                    {
                        type: "bytes32[]"
                    },
                    {
                        type: "bytes"
                    }
                ]
            },
            {
                type: "bytes"
            }
        ];
        const paddedSignature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])(abiParameters, [
            this.getSessionKeyManagerAddress(),
            sessionDataTupleArray,
            this.mockEcdsaSessionKeySig
        ]);
        const dummySig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("bytes, address"), [
            paddedSignature,
            this.getAddress()
        ]);
        return dummySig;
    }
    /**
     * @remarks Other modules may need additional attributes to build init data
     */ async getInitData() {
        throw new Error("Method not implemented.");
    }
    /**
     * @remarks This Module dont have knowledge of signer. So, this method is not implemented
     */ async signMessage(_message) {
        throw new Error("Method not implemented.");
    }
} //# sourceMappingURL=BatchedSessionRouterModule.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/ECDSAOwnershipValidationModule.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ECDSAOwnershipValidationModule",
    ()=>ECDSAOwnershipValidationModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeFunctionData.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toBytes.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/convertSigner.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/BaseValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Constants.js [client] (ecmascript)");
;
;
;
;
class ECDSAOwnershipValidationModule extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseValidationModule"] {
    constructor(moduleConfig){
        super(moduleConfig);
        Object.defineProperty(this, "signer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "moduleAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "V1_0_0"
        });
        this.signer = moduleConfig.signer;
    }
    static async create(moduleConfig) {
        // Signer needs to be initialised here before defaultValidationModule is set
        const { signer } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(moduleConfig.signer, false);
        const configForConstructor = {
            ...moduleConfig,
            signer
        };
        // TODO: (Joe) stop doing things in a 'create' call after the instance has been created
        const instance = new ECDSAOwnershipValidationModule(configForConstructor);
        if (moduleConfig.moduleAddress) {
            instance.moduleAddress = moduleConfig.moduleAddress;
        } else if (moduleConfig.version) {
            const moduleAddr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ECDSA_OWNERSHIP_MODULE_ADDRESSES_BY_VERSION"][moduleConfig.version];
            if (!moduleAddr) {
                throw new Error(`Invalid version ${moduleConfig.version}`);
            }
            instance.moduleAddress = moduleAddr;
            instance.version = moduleConfig.version;
        } else {
            instance.moduleAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ECDSA_OWNERSHIP_MODULE"];
        // Note: in this case Version remains the default one
        }
        return instance;
    }
    getAddress() {
        return this.moduleAddress;
    }
    async getSigner() {
        return Promise.resolve(this.signer);
    }
    async getDummySignature() {
        const moduleAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAddress"])(this.getAddress());
        const dynamicPart = moduleAddress.substring(2).padEnd(40, "0");
        return `0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000${dynamicPart}000000000000000000000000000000000000000000000000000000000000004181d4b4981670cb18f99f0b4a66446df1bf5b204d24cfcb659bf38ba27a4359b5711649ec2423c5e1247245eba2964679b6a1dbb85c992ae40b9b00c6935b02ff1b00000000000000000000000000000000000000000000000000000000000000`;
    }
    // Note: other modules may need additional attributes to build init data
    async getInitData() {
        const ecdsaOwnerAddress = await this.signer.getAddress();
        const moduleRegistryParsedAbi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbi"])([
            "function initForSmartAccount(address owner)"
        ]);
        const ecdsaOwnershipInitData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: moduleRegistryParsedAbi,
            functionName: "initForSmartAccount",
            args: [
                ecdsaOwnerAddress
            ]
        });
        return ecdsaOwnershipInitData;
    }
    async signUserOpHash(userOpHash) {
        const sig = await this.signer.signMessage({
            raw: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBytes"])(userOpHash)
        });
        return sig;
    }
    /**
     * Signs a message using the appropriate method based on the type of signer.
     *
     * @param {Uint8Array | string} message - The message to be signed.
     * @returns {Promise<string>} A promise resolving to the signature or error message.
     * @throws {Error} If the signer type is invalid or unsupported.
     */ async signMessage(_message) {
        const message = typeof _message === "string" ? _message : {
            raw: _message
        };
        let signature = await this.signer.signMessage(message);
        const potentiallyIncorrectV = Number.parseInt(signature.slice(-2), 16);
        if (![
            27,
            28
        ].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        return signature;
    }
} //# sourceMappingURL=ECDSAOwnershipValidationModule.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/session-validation-modules/ERC20SessionValidationModule.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERC20SessionValidationModule",
    ()=>ERC20SessionValidationModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [client] (ecmascript)");
;
class ERC20SessionValidationModule {
    /**
     * This constructor is private. Use the static create method to instantiate ERC20SessionValidationModule
     * @param moduleConfig The configuration for the module
     * @returns An instance of ERC20SessionValidationModule
     */ constructor(moduleConfig){
        Object.defineProperty(this, "moduleAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "V1_0_0"
        });
        if (!moduleConfig.moduleAddress) {
            throw new Error("Module address is required");
        }
        this.moduleAddress = moduleConfig.moduleAddress;
    }
    /**
     * Asynchronously creates and initializes an instance of ERC20SessionValidationModule
     * @param moduleConfig The configuration for the module
     * @returns A Promise that resolves to an instance of ERC20SessionValidationModule
     */ static async create(moduleConfig) {
        const module = new ERC20SessionValidationModule(moduleConfig);
        return module;
    }
    async getSessionKeyData(sessionData) {
        this._validateSessionKeyData(sessionData);
        const sessionKeyData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("address, address, address, uint256"), [
            sessionData.sessionKey,
            sessionData.token,
            sessionData.recipient,
            sessionData.maxAmount
        ]);
        return sessionKeyData;
    }
    _validateSessionKeyData(sessionData) {
        if (!sessionData) {
            throw new Error("Session data is required");
        }
        if (!sessionData.sessionKey) {
            throw new Error("Session key is required in sessionData");
        }
        if (!sessionData.token) {
            throw new Error("Token address is required in sessionData");
        }
        if (!sessionData.recipient) {
            throw new Error("Recipient address is required in sessionData");
        }
        if (!sessionData.maxAmount) {
            throw new Error("MaxAmount is required in sessionData");
        }
    }
    getAddress() {
        return this.moduleAddress;
    }
} //# sourceMappingURL=ERC20SessionValidationModule.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/MultichainValidationModule.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MultiChainValidationModule",
    ()=>MultiChainValidationModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merkletreejs$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/merkletreejs/dist/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeFunctionData.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/pad.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toBytes.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/convertSigner.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/BaseValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Helper.js [client] (ecmascript)");
;
;
;
;
;
;
class MultiChainValidationModule extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseValidationModule"] {
    constructor(moduleConfig){
        super(moduleConfig);
        Object.defineProperty(this, "signer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "moduleAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "V1_0_0"
        });
        this.signer = moduleConfig.signer;
    }
    static async create(moduleConfig) {
        // Signer needs to be initialised here before defaultValidationModule is set
        const { signer } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(moduleConfig.signer, false);
        const configForConstructor = {
            ...moduleConfig,
            signer
        };
        // TODO: (Joe) stop doing things in a 'create' call after the instance has been created
        const instance = new MultiChainValidationModule(configForConstructor);
        if (moduleConfig.moduleAddress) {
            instance.moduleAddress = moduleConfig.moduleAddress;
        } else if (moduleConfig.version) {
            const moduleAddr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MULTICHAIN_VALIDATION_MODULE_ADDRESSES_BY_VERSION"][moduleConfig.version];
            if (!moduleAddr) {
                throw new Error(`Invalid version ${moduleConfig.version}`);
            }
            instance.moduleAddress = moduleAddr;
            instance.version = moduleConfig.version;
        } else {
            instance.moduleAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_MULTICHAIN_MODULE"];
        // Note: in this case Version remains the default one
        }
        return instance;
    }
    getAddress() {
        return this.moduleAddress;
    }
    async getSigner() {
        return Promise.resolve(this.signer);
    }
    async getDummySignature() {
        const moduleAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getAddress"])(this.getAddress());
        const dynamicPart = moduleAddress.substring(2).padEnd(40, "0");
        return `0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000${dynamicPart}000000000000000000000000000000000000000000000000000000000000004181d4b4981670cb18f99f0b4a66446df1bf5b204d24cfcb659bf38ba27a4359b5711649ec2423c5e1247245eba2964679b6a1dbb85c992ae40b9b00c6935b02ff1b00000000000000000000000000000000000000000000000000000000000000`;
    }
    // Note: other modules may need additional attributes to build init data
    async getInitData() {
        const ecdsaOwnerAddress = await this.signer.getAddress();
        const moduleRegistryParsedAbi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbi"])([
            "function initForSmartAccount(address owner)"
        ]);
        const ecdsaOwnershipInitData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: moduleRegistryParsedAbi,
            functionName: "initForSmartAccount",
            args: [
                ecdsaOwnerAddress
            ]
        });
        return ecdsaOwnershipInitData;
    }
    async signUserOpHash(userOpHash) {
        const sig = await this.signer.signMessage({
            raw: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBytes"])(userOpHash)
        });
        return sig;
    }
    /**
     * Signs a message using the appropriate method based on the type of signer.
     *
     * @param {Uint8Array | string} message - The message to be signed.
     * @returns {Promise<string>} A promise resolving to the signature or error message.
     * @throws {Error} If the signer type is invalid or unsupported.
     */ async signMessage(_message) {
        const message = typeof _message === "string" ? _message : {
            raw: _message
        };
        let signature = await this.signer.signMessage(message);
        const potentiallyIncorrectV = Number.parseInt(signature.slice(-2), 16);
        if (![
            27,
            28
        ].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        return signature;
    }
    async signUserOps(multiChainUserOps) {
        try {
            const leaves = [];
            // Iterate over each userOp and process them
            for (const multiChainOp of multiChainUserOps){
                const validUntil = multiChainOp.validUntil ?? 0;
                const validAfter = multiChainOp.validAfter ?? 0;
                const leaf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(validUntil), {
                        size: 6
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(validAfter), {
                        size: 6
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getUserOpHash"])(multiChainOp.userOp, this.entryPointAddress, multiChainOp.chainId), {
                        size: 32
                    })
                ]);
                leaves.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(leaf));
            }
            // Create a new Merkle tree using the leaves array
            const merkleTree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$merkletreejs$2f$dist$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MerkleTree"](leaves, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"], {
                sortPairs: true
            });
            let multichainSignature = await this.signer.signMessage({
                raw: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBytes"])(merkleTree.getHexRoot())
            });
            const potentiallyIncorrectV = Number.parseInt(multichainSignature.slice(-2), 16);
            if (![
                27,
                28
            ].includes(potentiallyIncorrectV)) {
                const correctV = potentiallyIncorrectV + 27;
                multichainSignature = multichainSignature.slice(0, -2) + correctV.toString(16);
            }
            // Create an array to store updated userOps
            const updatedUserOps = [];
            for(let i = 0; i < leaves.length; i++){
                const merkleProof = merkleTree.getHexProof(leaves[i]);
                const validUntil = multiChainUserOps[i].validUntil ?? 0;
                const validAfter = multiChainUserOps[i].validAfter ?? 0;
                // Create the moduleSignature
                const moduleSignature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])([
                    "uint48, uint48, bytes32, bytes32[], bytes"
                ]), [
                    validUntil,
                    validAfter,
                    merkleTree.getHexRoot(),
                    merkleProof,
                    multichainSignature
                ]);
                // Note: Because accountV2 does not directly call this method. hence we need to add validation module address to the signature
                const signatureWithModuleAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])([
                    "bytes, address"
                ]), [
                    moduleSignature,
                    this.getAddress()
                ]);
                // Update userOp with the final signature
                const updatedUserOp = {
                    ...multiChainUserOps[i].userOp,
                    signature: signatureWithModuleAddress
                };
                updatedUserOps.push(updatedUserOp);
            }
            return updatedUserOps;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].error("Error in signing multi chain userops");
            throw new Error(JSON.stringify(error));
        }
    }
} //# sourceMappingURL=MultichainValidationModule.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/index.js [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createBatchedSessionRouterModule",
    ()=>createBatchedSessionRouterModule,
    "createECDSAOwnershipValidationModule",
    ()=>createECDSAOwnershipValidationModule,
    "createERC20SessionValidationModule",
    ()=>createERC20SessionValidationModule,
    "createMultiChainValidationModule",
    ()=>createMultiChainValidationModule,
    "createSessionKeyManagerModule",
    ()=>createSessionKeyManagerModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BatchedSessionRouterModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/BatchedSessionRouterModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$ECDSAOwnershipValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/ECDSAOwnershipValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$validation$2d$modules$2f$ERC20SessionValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-validation-modules/ERC20SessionValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$MultichainValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/MultichainValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$SessionKeyManagerModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/SessionKeyManagerModule.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const createBatchedSessionRouterModule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BatchedSessionRouterModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BatchedSessionRouterModule"].create;
const createMultiChainValidationModule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$MultichainValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MultiChainValidationModule"].create;
const createECDSAOwnershipValidationModule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$ECDSAOwnershipValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ECDSAOwnershipValidationModule"].create;
const createSessionKeyManagerModule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$SessionKeyManagerModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["SessionKeyManagerModule"].create;
const createERC20SessionValidationModule = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$validation$2d$modules$2f$ERC20SessionValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERC20SessionValidationModule"].create; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Utils.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addressEquals",
    ()=>addressEquals,
    "compareChainIds",
    ()=>compareChainIds,
    "convertToFactor",
    ()=>convertToFactor,
    "isNullOrUndefined",
    ()=>isNullOrUndefined,
    "isValidRpcUrl",
    ()=>isValidRpcUrl,
    "packUserOp",
    ()=>packUserOp,
    "percentage",
    ()=>percentage,
    "wrapSignatureWith6492",
    ()=>wrapSignatureWith6492
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/convertSigner.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/Utils.js [client] (ecmascript)");
;
;
;
;
function packUserOp(op, forSignature = true) {
    if (!op.initCode || !op.callData || !op.paymasterAndData) throw new Error("Missing userOp properties");
    if (forSignature) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("address, uint256, bytes32, bytes32, uint256, uint256, uint256, uint256, uint256, bytes32"), [
            op.sender,
            BigInt(op.nonce),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(op.initCode),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(op.callData),
            BigInt(op.callGasLimit),
            BigInt(op.verificationGasLimit),
            BigInt(op.preVerificationGas),
            BigInt(op.maxFeePerGas),
            BigInt(op.maxPriorityFeePerGas),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(op.paymasterAndData)
        ]);
    }
    // for the purpose of calculating gas cost encode also signature (and no keccak of bytes)
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("address, uint256, bytes, bytes, uint256, uint256, uint256, uint256, uint256, bytes, bytes"), [
        op.sender,
        BigInt(op.nonce),
        op.initCode,
        op.callData,
        BigInt(op.callGasLimit),
        BigInt(op.verificationGasLimit),
        BigInt(op.preVerificationGas),
        BigInt(op.maxFeePerGas),
        BigInt(op.maxPriorityFeePerGas),
        op.paymasterAndData,
        op.signature
    ]);
}
const isNullOrUndefined = (value)=>{
    return value === null || value === undefined;
};
const compareChainIds = async (signer, biconomySmartAccountConfig, skipChainIdCalls)=>{
    const signerResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(signer, skipChainIdCalls, biconomySmartAccountConfig.rpcUrl);
    const chainIdFromBundler = biconomySmartAccountConfig.bundlerUrl ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractChainIdFromBundlerUrl"])(biconomySmartAccountConfig.bundlerUrl) : biconomySmartAccountConfig.bundler ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractChainIdFromBundlerUrl"])(biconomySmartAccountConfig.bundler.getBundlerUrl()) : undefined;
    const chainIdFromPaymasterUrl = biconomySmartAccountConfig.paymasterUrl ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractChainIdFromPaymasterUrl"])(biconomySmartAccountConfig.paymasterUrl) : undefined;
    if (!isNullOrUndefined(signerResult.chainId)) {
        if (chainIdFromBundler !== undefined && signerResult.chainId !== chainIdFromBundler) {
            throw new Error(`Chain IDs from signer (${signerResult.chainId}) and bundler (${chainIdFromBundler}) do not match.`);
        }
        if (chainIdFromPaymasterUrl !== undefined && signerResult.chainId !== chainIdFromPaymasterUrl) {
            throw new Error(`Chain IDs from signer (${signerResult.chainId}) and paymaster (${chainIdFromPaymasterUrl}) do not match.`);
        }
    } else {
        if (chainIdFromBundler !== undefined && chainIdFromPaymasterUrl !== undefined && chainIdFromBundler !== chainIdFromPaymasterUrl) {
            throw new Error(`Chain IDs from bundler (${chainIdFromBundler}) and paymaster (${chainIdFromPaymasterUrl}) do not match.`);
        }
    }
};
const isValidRpcUrl = (url)=>{
    const regex = /^(https:\/\/|wss:\/\/).*/;
    return regex.test(url);
};
const addressEquals = (a, b)=>!!a && !!b && a?.toLowerCase() === b.toLowerCase();
const wrapSignatureWith6492 = ({ factoryAddress, factoryCalldata, signature })=>{
    // wrap the signature as follows: https://eips.ethereum.org/EIPS/eip-6492
    // concat(
    //  abi.encode(
    //    (create2Factory, factoryCalldata, originalERC1271Signature),
    //    (address, bytes, bytes)),
    //    magicBytes
    // )
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("address, bytes, bytes"), [
            factoryAddress,
            factoryCalldata,
            signature
        ]),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAGIC_BYTES"]
    ]);
};
function percentage(partialValue, totalValue) {
    return 100 * partialValue / totalValue;
}
function convertToFactor(percentage) {
    // Check if the input is within the valid range
    if (percentage) {
        if (percentage < 1 || percentage > 100) {
            throw new Error("The percentage value should be between 1 and 100.");
        }
        // Calculate the factor
        const factor = percentage / 100 + 1;
        return factor;
    }
    return 1;
} //# sourceMappingURL=Utils.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/sessions/batch.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createBatchSession",
    ()=>createBatchSession,
    "getBatchSessionTxParams",
    ()=>getBatchSessionTxParams
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Helper.js [client] (ecmascript)");
;
;
const createBatchSession = async (smartAccount, /** The storage client to be used for storing the session data */ sessionStorageClient, /** An array of session configurations */ leaves, buildUseropDto)=>{
    const smartAccountAddress = await smartAccount.getAddress();
    const sessionsModule = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSessionKeyManagerModule"])({
        smartAccountAddress,
        sessionStorageClient
    });
    // Create batched session module
    const batchedSessionModule = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createBatchedSessionRouterModule"])({
        smartAccountAddress,
        sessionKeyManagerModule: sessionsModule
    });
    const { data: policyData, sessionIDInfo } = await batchedSessionModule.createSessionData(leaves);
    const permitTx = {
        to: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"],
        data: policyData
    };
    const isDeployed = await smartAccount.isAccountDeployed();
    const txs = [];
    const enableSessionKeyTx = await smartAccount.getEnableModuleData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"]);
    const enableBatchedSessionTx = await smartAccount.getEnableModuleData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_BATCHED_SESSION_ROUTER_MODULE"]);
    if (isDeployed) {
        const [isSessionModuleEnabled, isBatchedSessionModuleEnabled] = await Promise.all([
            smartAccount.isModuleEnabled(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"]),
            smartAccount.isModuleEnabled(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_BATCHED_SESSION_ROUTER_MODULE"])
        ]);
        if (!isSessionModuleEnabled) {
            txs.push(enableSessionKeyTx);
        }
        if (!isBatchedSessionModuleEnabled) {
            txs.push(enableBatchedSessionTx);
        }
    } else {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].ACCOUNT_NOT_DEPLOYED);
        txs.push(enableSessionKeyTx, enableBatchedSessionTx);
    }
    txs.push(permitTx);
    const userOpResponse = await smartAccount.sendTransaction(txs, buildUseropDto);
    return {
        session: {
            sessionStorageClient,
            sessionIDInfo
        },
        ...userOpResponse
    };
};
const getBatchSessionTxParams = async (transactions, correspondingIndexes, conditionalSession, chain)=>{
    if (correspondingIndexes && correspondingIndexes.length !== transactions.length) {
        throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].INVALID_SESSION_INDEXES);
    }
    const { sessionStorageClient } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__["resumeSession"])(conditionalSession);
    let sessionIDInfo = [];
    const allSessions = await sessionStorageClient.getAllSessionData();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__["didProvideFullSession"])(conditionalSession)) {
        sessionIDInfo = conditionalSession.sessionIDInfo;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNullOrUndefined"])(correspondingIndexes)) {
        sessionIDInfo = allSessions.slice(-transactions.length).map(({ sessionID })=>sessionID);
    } else {
        sessionIDInfo = (correspondingIndexes ?? []).map((index)=>allSessions[index].sessionID);
    }
    const sessionSigner = await sessionStorageClient.getSignerBySession({
        sessionID: sessionIDInfo[0]
    }, chain);
    return {
        params: {
            batchSessionParams: sessionIDInfo.map((sessionID)=>({
                    sessionSigner,
                    sessionID
                }))
        }
    };
}; //# sourceMappingURL=batch.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/modules/sessions/abi.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PolicyHelpers",
    ()=>PolicyHelpers,
    "RuleHelpers",
    ()=>RuleHelpers,
    "createABISessionDatum",
    ()=>createABISessionDatum,
    "createSession",
    ()=>createSession,
    "getABISVMSessionKeyData",
    ()=>getABISVMSessionKeyData,
    "getSessionDatum",
    ()=>getSessionDatum,
    "getSingleSessionTxParams",
    ()=>getSingleSessionTxParams,
    "parseReferenceValue",
    ()=>parseReferenceValue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/pad.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$slice$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/slice.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$toFunctionSelector$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/toFunctionSelector.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Helper.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/getChain.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/Utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/utils/Constants.js [client] (ecmascript)");
;
;
;
;
;
;
const PolicyHelpers = {
    Indefinitely: {
        validUntil: 0,
        validAfter: 0
    },
    NoValueLimit: 0n
};
const RULE_CONDITIONS = [
    "EQUAL",
    "LASS_THAN_OR_EQUAL",
    "LESS_THAN",
    "GREATER_THAN_OR_EQUAL",
    "GREATER_THAN",
    "NOT_EQUAL"
];
const RuleHelpers = {
    OffsetByIndex: (i)=>i * 32,
    Condition: (condition)=>RULE_CONDITIONS.indexOf(condition)
};
const createSession = async (smartAccount, policy, sessionStorageClient, buildUseropDto)=>{
    const smartAccountAddress = await smartAccount.getAddress();
    const defaultedChainId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractChainIdFromBundlerUrl"])(smartAccount?.bundler?.getBundlerUrl() ?? "");
    if (!defaultedChainId) {
        throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].CHAIN_NOT_FOUND);
    }
    const chain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(defaultedChainId);
    const { sessionKeyAddress, sessionStorageClient: storageClientFromCreateKey } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createSessionKeyEOA"])(smartAccount, chain);
    const defaultedSessionStorageClient = sessionStorageClient ?? storageClientFromCreateKey;
    const sessionsModule = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSessionKeyManagerModule"])({
        smartAccountAddress,
        sessionStorageClient: defaultedSessionStorageClient
    });
    const defaultedPolicy = policy.map((p)=>!p.sessionKeyAddress ? {
            ...p,
            sessionKeyAddress
        } : p);
    const humanReadablePolicyArray = defaultedPolicy.map(createABISessionDatum);
    const { data: policyData, sessionIDInfo } = await sessionsModule.createSessionData(humanReadablePolicyArray);
    const permitTx = {
        to: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"],
        data: policyData
    };
    const txs = [];
    const isDeployed = await smartAccount.isAccountDeployed();
    const enableSessionTx = await smartAccount.getEnableModuleData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"]);
    if (isDeployed) {
        const enabled = await smartAccount.isModuleEnabled(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_KEY_MANAGER_MODULE"]);
        if (!enabled) {
            txs.push(enableSessionTx);
        }
    } else {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].ACCOUNT_NOT_DEPLOYED);
        txs.push(enableSessionTx);
    }
    txs.push(permitTx);
    const userOpResponse = await smartAccount.sendTransaction(txs, buildUseropDto);
    return {
        session: {
            sessionStorageClient: defaultedSessionStorageClient,
            sessionIDInfo
        },
        ...userOpResponse
    };
};
const createABISessionDatum = ({ /** The time interval within which the session is valid. If left unset the session will remain invalid indefinitely {@link SessionEpoch} */ interval, /** The sessionKeyAddress upon which the policy is to be imparted. Used as a reference to the stored session keys */ sessionKeyAddress, /** The address of the contract to be included in the policy */ contractAddress, /** The specific function selector from the contract to be included in the policy */ functionSelector, /** The rules to be included in the policy */ rules, /** The maximum value that can be transferred in a single transaction */ valueLimit, /** information pertinent to the DAN module */ danModuleInfo })=>{
    const { validUntil = 0, validAfter = 0 } = interval ?? {};
    let parsedFunctionSelector = "0x";
    const rawFunctionSelectorWasProvided = !!functionSelector?.raw;
    if (rawFunctionSelectorWasProvided) {
        parsedFunctionSelector = functionSelector.raw;
    } else {
        const unparsedFunctionSelector = functionSelector;
        parsedFunctionSelector = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$slice$2e$js__$5b$client$5d$__$28$ecmascript$29$__["slice"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$toFunctionSelector$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toFunctionSelector"])(unparsedFunctionSelector), 0, 4);
    }
    const result = {
        validUntil,
        validAfter,
        sessionValidationModule: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ABI_SVM_MODULE"],
        sessionPublicKey: sessionKeyAddress,
        sessionKeyData: getSessionDatum(sessionKeyAddress, {
            destContract: contractAddress,
            functionSelector: parsedFunctionSelector,
            valueLimit,
            rules
        })
    };
    return danModuleInfo ? {
        ...result,
        danModuleInfo
    } : result;
};
async function getABISVMSessionKeyData(sessionKey, permission) {
    let sessionKeyData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        sessionKey,
        permission.destContract,
        permission.functionSelector,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.valueLimit), {
            size: 16
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.rules.length), {
            size: 2
        })
    ]);
    for(let i = 0; i < permission.rules.length; i++){
        sessionKeyData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
            sessionKeyData,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.rules[i].offset), {
                size: 2
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.rules[i].condition), {
                size: 1
            }),
            permission.rules[i].referenceValue
        ]);
    }
    return sessionKeyData;
}
function getSessionDatum(sessionKeyAddress, permission) {
    let sessionKeyData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
        sessionKeyAddress,
        permission.destContract,
        permission.functionSelector,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.valueLimit), {
            size: 16
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.rules.length), {
            size: 2
        })
    ]);
    for(let i = 0; i < permission.rules.length; i++){
        sessionKeyData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
            sessionKeyData,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.rules[i].offset), {
                size: 2
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(permission.rules[i].condition), {
                size: 1
            }),
            parseReferenceValue(permission.rules[i].referenceValue)
        ]);
    }
    return sessionKeyData;
}
function parseReferenceValue(referenceValue) {
    try {
        if (referenceValue?.raw) {
            return referenceValue?.raw;
        }
        if (typeof referenceValue === "bigint") {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(referenceValue), {
                size: 32
            });
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(referenceValue, {
            size: 32
        });
    } catch (e) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$client$5d$__$28$ecmascript$29$__["pad"])(referenceValue, {
            size: 32
        });
    }
}
const getSingleSessionTxParams = async (conditionalSession, chain, correspondingIndex)=>{
    const { sessionStorageClient } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__["resumeSession"])(conditionalSession);
    // if correspondingIndex is null then use the last session.
    const allSessions = await sessionStorageClient.getAllSessionData();
    const sessionID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$utils$2f$Helper$2e$js__$5b$client$5d$__$28$ecmascript$29$__["didProvideFullSession"])(conditionalSession) ? conditionalSession.sessionIDInfo[correspondingIndex ?? 0] : allSessions[correspondingIndex ?? allSessions.length - 1].sessionID;
    const sessionSigner = await sessionStorageClient.getSignerBySession({
        sessionID
    }, chain);
    return {
        params: {
            sessionSigner,
            sessionID
        }
    };
}; //# sourceMappingURL=abi.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/paymaster/utils/Constants.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ADDRESS_ZERO",
    ()=>ADDRESS_ZERO,
    "ENTRYPOINT_ADDRESS",
    ()=>ENTRYPOINT_ADDRESS,
    "ERC20_ABI",
    ()=>ERC20_ABI,
    "MAX_UINT256",
    ()=>MAX_UINT256
]);
const MAX_UINT256 = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
const ENTRYPOINT_ADDRESS = "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789";
const ADDRESS_ZERO = "0x0000000000000000000000000000000000000000";
const ERC20_ABI = [
    "function transfer(address to, uint256 value) external returns (bool)",
    "function transferFrom(address from, address to, uint256 value) external returns (bool)",
    "function approve(address spender, uint256 value) external returns (bool)",
    "function allowance(address owner, address spender) external view returns (uint256)",
    "function balanceOf(address owner) external view returns (uint256)"
]; //# sourceMappingURL=Constants.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/paymaster/utils/Helpers.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @description this function will return current timestamp in seconds
 * @returns Number
 */ __turbopack_context__.s([
    "getTimestampInSeconds",
    ()=>getTimestampInSeconds
]);
const getTimestampInSeconds = ()=>{
    return Math.floor(Date.now() / 1000);
}; //# sourceMappingURL=Helpers.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/paymaster/utils/Types.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PaymasterMode",
    ()=>PaymasterMode
]);
var PaymasterMode;
(function(PaymasterMode) {
    PaymasterMode["ERC20"] = "ERC20";
    PaymasterMode["SPONSORED"] = "SPONSORED";
})(PaymasterMode || (PaymasterMode = {})); //# sourceMappingURL=Types.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/paymaster/BiconomyPaymaster.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BiconomyPaymaster",
    ()=>BiconomyPaymaster
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeFunctionData.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/HttpRequests.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/paymaster/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Helpers$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/paymaster/utils/Helpers.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/paymaster/utils/Types.js [client] (ecmascript)");
;
;
;
;
;
const defaultPaymasterConfig = {
    paymasterUrl: "",
    strictMode: false // Set your desired default value for strictMode here
};
class BiconomyPaymaster {
    constructor(config){
        Object.defineProperty(this, "paymasterConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const mergedConfig = {
            ...defaultPaymasterConfig,
            ...config
        };
        this.paymasterConfig = mergedConfig;
    }
    /**
     * @dev Prepares the user operation by resolving properties and converting certain values to hexadecimal format.
     * @param userOp The partial user operation.
     * @returns A Promise that resolves to the prepared partial user operation.
     */ async prepareUserOperation(userOp) {
        const userOperation = {
            ...userOp
        };
        try {
            const keys1 = [
                "nonce",
                "maxFeePerGas",
                "maxPriorityFeePerGas"
            ];
            for (const key of keys1){
                if (userOperation[key] && userOperation[key] !== "0x") {
                    userOperation[key] = `0x${BigInt(userOp[key]).toString(16)}`;
                }
            }
            const keys2 = [
                "callGasLimit",
                "verificationGasLimit",
                "preVerificationGas"
            ];
            for (const key of keys2){
                if (userOperation[key] && userOperation[key] !== "0x") {
                    userOperation[key] = BigInt(userOp[key]).toString();
                }
            }
        } catch (error) {
            throw `Failed to transform user operation: ${error}`;
        }
        userOperation.signature = userOp.signature || "0x";
        userOperation.paymasterAndData = userOp.paymasterAndData || "0x";
        return userOperation;
    }
    /**
     * @dev Builds a token approval transaction for the Biconomy token paymaster.
     * @param tokenPaymasterRequest The token paymaster request data. This will include information about chosen feeQuote, spender address and optional flag to provide maxApproval
     * @param provider Optional provider object.
     * @returns A Promise that resolves to the built transaction object.
     */ async buildTokenApprovalTransaction(tokenPaymasterRequest) {
        const feeTokenAddress = tokenPaymasterRequest.feeQuote.tokenAddress;
        const spender = tokenPaymasterRequest.spender;
        // logging provider object isProvider
        // Logger.log("provider object passed - is provider", provider?._isProvider);
        // TODO move below notes to separate method
        // Note: should also check in caller if the approval is already given, if yes return object with address or data 0
        // Note: we would need userOp here to get the account/owner info to check allowance
        let requiredApproval = BigInt(0);
        if (tokenPaymasterRequest.maxApproval && tokenPaymasterRequest.maxApproval === true) {
            requiredApproval = BigInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAX_UINT256"]);
        } else {
            requiredApproval = BigInt(Math.ceil(tokenPaymasterRequest.feeQuote.maxGasFee * 10 ** tokenPaymasterRequest.feeQuote.decimal));
        }
        try {
            const parsedAbi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbi"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERC20_ABI"]);
            const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
                abi: parsedAbi,
                functionName: "approve",
                args: [
                    spender,
                    requiredApproval
                ]
            });
            // TODO?
            // Note: For some tokens we may need to set allowance to 0 first so that would return batch of transactions and changes the return type to Transaction[]
            // In that case we would return two objects in an array, first of them being..
            /*
          {
            to: erc20.address,
            value: ethers.BigNumber.from(0),
            data: erc20.interface.encodeFunctionData('approve', [spender, BigNumber.from("0")])
          }
          */ // const zeroValue: ethers.BigNumber = ethers.BigNumber.from(0);
            // const value: BigNumberish | undefined = zeroValue as any;
            return {
                to: feeTokenAddress,
                value: "0x00",
                data: data
            };
        } catch (error) {
            throw new Error("Failed to encode function data");
        }
    }
    /**
     * @dev Retrieves paymaster fee quotes or data based on the provided user operation and paymaster service data.
     * @param userOp The partial user operation.
     * @param paymasterServiceData The paymaster service data containing token information and sponsorship details. Devs can send just the preferred token or array of token addresses in case of mode "ERC20" and sartAccountInfo in case of "sponsored" mode.
     * @returns A Promise that resolves to the fee quotes or data response.
     */ async getPaymasterFeeQuotesOrData(_userOp, paymasterServiceData) {
        const userOp = await this.prepareUserOperation(_userOp);
        let mode = null;
        let expiryDuration = null;
        const calculateGasLimits = paymasterServiceData.calculateGasLimits ?? true;
        let preferredToken = null;
        let feeTokensArray = [];
        // could make below null
        let smartAccountInfo = {
            name: "BICONOMY",
            version: "2.0.0"
        };
        let webhookData = null;
        if (paymasterServiceData.mode) {
            mode = paymasterServiceData.mode;
        // Validation on the mode passed / define allowed enums
        }
        if (paymasterServiceData.expiryDuration) {
            expiryDuration = paymasterServiceData.expiryDuration;
        }
        preferredToken = paymasterServiceData?.preferredToken ? paymasterServiceData?.preferredToken : preferredToken;
        feeTokensArray = paymasterServiceData?.tokenList?.length !== 0 ? paymasterServiceData?.tokenList : feeTokensArray;
        webhookData = paymasterServiceData?.webhookData ?? webhookData;
        smartAccountInfo = paymasterServiceData?.smartAccountInfo ?? smartAccountInfo;
        try {
            const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
                url: `${this.paymasterConfig.paymasterUrl}`,
                method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
                body: {
                    method: "pm_getFeeQuoteOrData",
                    params: [
                        userOp,
                        {
                            ...mode !== null && {
                                mode
                            },
                            calculateGasLimits: calculateGasLimits,
                            ...expiryDuration !== null && {
                                expiryDuration
                            },
                            tokenInfo: {
                                tokenList: feeTokensArray,
                                ...preferredToken !== null && {
                                    preferredToken
                                }
                            },
                            sponsorshipInfo: {
                                ...webhookData !== null && {
                                    webhookData
                                },
                                smartAccountInfo: smartAccountInfo
                            }
                        }
                    ],
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Helpers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                    jsonrpc: "2.0"
                }
            }, "Paymaster");
            if (response?.result) {
                if (response.result.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].ERC20) {
                    const feeQuotesResponse = response.result.feeQuotes;
                    const paymasterAddress = response.result.paymasterAddress;
                    // check all objects iterate and populate below calculation for all tokens
                    return {
                        feeQuotes: feeQuotesResponse,
                        tokenPaymasterAddress: paymasterAddress
                    };
                }
                if (response.result.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].SPONSORED) {
                    const paymasterAndData = response.result.paymasterAndData;
                    const preVerificationGas = response.result.preVerificationGas;
                    const verificationGasLimit = response.result.verificationGasLimit;
                    const callGasLimit = response.result.callGasLimit;
                    return {
                        paymasterAndData: paymasterAndData,
                        preVerificationGas: preVerificationGas,
                        verificationGasLimit: verificationGasLimit,
                        callGasLimit: callGasLimit
                    };
                }
                const errorObject = {
                    code: 417,
                    message: "Expectation Failed: Invalid mode in Paymaster service response"
                };
                throw errorObject;
            }
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].error("Failed to fetch Fee Quotes or Paymaster data - reason: ", JSON.stringify(error));
            // Note: we may not throw if we include strictMode off and return paymasterData '0x'.
            if (!this.paymasterConfig.strictMode && paymasterServiceData.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].SPONSORED && (error?.message.includes("Smart contract data not found") || error?.message.includes("No policies were set"))) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn(`Strict mode is ${this.paymasterConfig.strictMode}. sending paymasterAndData 0x`);
                return {
                    paymasterAndData: "0x",
                    // send below values same as userOp gasLimits
                    preVerificationGas: userOp.preVerificationGas,
                    verificationGasLimit: userOp.verificationGasLimit,
                    callGasLimit: userOp.callGasLimit
                };
            }
            throw error;
        }
        throw new Error("Failed to fetch feeQuote or paymaster data");
    }
    /**
     * @dev Retrieves the paymaster and data based on the provided user operation and paymaster service data.
     * @param userOp The partial user operation.
     * @param paymasterServiceData Optional paymaster service data.
     * @returns A Promise that resolves to the paymaster and data string.
     */ async getPaymasterAndData(_userOp, paymasterServiceData // mode is necessary. partial context of token paymaster or verifying
    ) {
        const userOp = await this.prepareUserOperation(_userOp);
        if (paymasterServiceData?.mode === undefined) {
            throw new Error("mode is required in paymasterServiceData");
        }
        const mode = paymasterServiceData.mode;
        const calculateGasLimits = paymasterServiceData.calculateGasLimits ?? true;
        let tokenInfo = null;
        // could make below null
        let smartAccountInfo = {
            name: "BICONOMY",
            version: "2.0.0"
        };
        let webhookData = null;
        let expiryDuration = null;
        if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].ERC20) {
            if (!paymasterServiceData?.feeTokenAddress && paymasterServiceData?.feeTokenAddress === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_ZERO"]) {
                throw new Error("feeTokenAddress is required and should be non-zero");
            }
            tokenInfo = {
                feeTokenAddress: paymasterServiceData.feeTokenAddress
            };
        }
        webhookData = paymasterServiceData?.webhookData ?? webhookData;
        smartAccountInfo = paymasterServiceData?.smartAccountInfo ?? smartAccountInfo;
        expiryDuration = paymasterServiceData?.expiryDuration ?? expiryDuration;
        // Note: The idea is before calling this below rpc, userOp values presense and types should be in accordance with how we call eth_estimateUseropGas on the bundler
        try {
            const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["sendRequest"])({
                url: `${this.paymasterConfig.paymasterUrl}`,
                method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$HttpRequests$2e$js__$5b$client$5d$__$28$ecmascript$29$__["HttpMethod"].Post,
                body: {
                    method: "pm_sponsorUserOperation",
                    params: [
                        userOp,
                        {
                            mode: mode,
                            calculateGasLimits: calculateGasLimits,
                            ...expiryDuration !== null && {
                                expiryDuration
                            },
                            ...tokenInfo !== null && {
                                tokenInfo
                            },
                            sponsorshipInfo: {
                                ...webhookData !== null && {
                                    webhookData
                                },
                                smartAccountInfo: smartAccountInfo
                            }
                        }
                    ],
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Helpers$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getTimestampInSeconds"])(),
                    jsonrpc: "2.0"
                }
            }, "Paymaster");
            if (response?.result) {
                const paymasterAndData = response.result.paymasterAndData;
                const preVerificationGas = response.result.preVerificationGas ?? _userOp.preVerificationGas;
                const verificationGasLimit = response.result.verificationGasLimit ?? _userOp.verificationGasLimit;
                const callGasLimit = response.result.callGasLimit ?? _userOp.callGasLimit;
                return {
                    paymasterAndData: paymasterAndData,
                    preVerificationGas: preVerificationGas,
                    verificationGasLimit: verificationGasLimit,
                    callGasLimit: callGasLimit
                };
            }
        // biome-ignore lint/suspicious/noExplicitAny: caught error is any
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].error("Error in generating paymasterAndData - reason: ", JSON.stringify(error));
            throw error;
        }
        throw new Error("Error in generating paymasterAndData");
    }
    /**
     *
     * @param userOp user operation
     * @param paymasterServiceData optional extra information to be passed to paymaster service
     * @returns "0x"
     */ async getDummyPaymasterAndData(_userOp, _paymasterServiceData // mode is necessary. partial context of token paymaster or verifying
    ) {
        return "0x";
    }
    static async create(config) {
        return new BiconomyPaymaster(config);
    }
} //# sourceMappingURL=BiconomyPaymaster.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/paymaster/index.js [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Paymaster",
    ()=>Paymaster,
    "createPaymaster",
    ()=>createPaymaster
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$BiconomyPaymaster$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/paymaster/BiconomyPaymaster.js [client] (ecmascript)");
;
;
;
;
;
const Paymaster = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$BiconomyPaymaster$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyPaymaster"];
const createPaymaster = Paymaster.create; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/abi/EntryPointAbi.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EntryPointAbi",
    ()=>EntryPointAbi
]);
const EntryPointAbi = [
    {
        inputs: [
            {
                internalType: "uint256",
                name: "preOpGas",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "paid",
                type: "uint256"
            },
            {
                internalType: "uint48",
                name: "validAfter",
                type: "uint48"
            },
            {
                internalType: "uint48",
                name: "validUntil",
                type: "uint48"
            },
            {
                internalType: "bool",
                name: "targetSuccess",
                type: "bool"
            },
            {
                internalType: "bytes",
                name: "targetResult",
                type: "bytes"
            }
        ],
        name: "ExecutionResult",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "opIndex",
                type: "uint256"
            },
            {
                internalType: "string",
                name: "reason",
                type: "string"
            }
        ],
        name: "FailedOp",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "sender",
                type: "address"
            }
        ],
        name: "SenderAddressResult",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "aggregator",
                type: "address"
            }
        ],
        name: "SignatureValidationFailed",
        type: "error"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "preOpGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "prefund",
                        type: "uint256"
                    },
                    {
                        internalType: "bool",
                        name: "sigFailed",
                        type: "bool"
                    },
                    {
                        internalType: "uint48",
                        name: "validAfter",
                        type: "uint48"
                    },
                    {
                        internalType: "uint48",
                        name: "validUntil",
                        type: "uint48"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterContext",
                        type: "bytes"
                    }
                ],
                internalType: "struct IEntryPoint.ReturnInfo",
                name: "returnInfo",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "stake",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "unstakeDelaySec",
                        type: "uint256"
                    }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "senderInfo",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "stake",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "unstakeDelaySec",
                        type: "uint256"
                    }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "factoryInfo",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "stake",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "unstakeDelaySec",
                        type: "uint256"
                    }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "paymasterInfo",
                type: "tuple"
            }
        ],
        name: "ValidationResult",
        type: "error"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "preOpGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "prefund",
                        type: "uint256"
                    },
                    {
                        internalType: "bool",
                        name: "sigFailed",
                        type: "bool"
                    },
                    {
                        internalType: "uint48",
                        name: "validAfter",
                        type: "uint48"
                    },
                    {
                        internalType: "uint48",
                        name: "validUntil",
                        type: "uint48"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterContext",
                        type: "bytes"
                    }
                ],
                internalType: "struct IEntryPoint.ReturnInfo",
                name: "returnInfo",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "stake",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "unstakeDelaySec",
                        type: "uint256"
                    }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "senderInfo",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "stake",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "unstakeDelaySec",
                        type: "uint256"
                    }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "factoryInfo",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "stake",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "unstakeDelaySec",
                        type: "uint256"
                    }
                ],
                internalType: "struct IStakeManager.StakeInfo",
                name: "paymasterInfo",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "address",
                        name: "aggregator",
                        type: "address"
                    },
                    {
                        components: [
                            {
                                internalType: "uint256",
                                name: "stake",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "unstakeDelaySec",
                                type: "uint256"
                            }
                        ],
                        internalType: "struct IStakeManager.StakeInfo",
                        name: "stakeInfo",
                        type: "tuple"
                    }
                ],
                internalType: "struct IEntryPoint.AggregatorStakeInfo",
                name: "aggregatorInfo",
                type: "tuple"
            }
        ],
        name: "ValidationResultWithAggregation",
        type: "error"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "userOpHash",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            },
            {
                indexed: false,
                internalType: "address",
                name: "factory",
                type: "address"
            },
            {
                indexed: false,
                internalType: "address",
                name: "paymaster",
                type: "address"
            }
        ],
        name: "AccountDeployed",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [],
        name: "BeforeExecution",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "totalDeposit",
                type: "uint256"
            }
        ],
        name: "Deposited",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "aggregator",
                type: "address"
            }
        ],
        name: "SignatureAggregatorChanged",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "totalStaked",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "unstakeDelaySec",
                type: "uint256"
            }
        ],
        name: "StakeLocked",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "withdrawTime",
                type: "uint256"
            }
        ],
        name: "StakeUnlocked",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: false,
                internalType: "address",
                name: "withdrawAddress",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "StakeWithdrawn",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "userOpHash",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "paymaster",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "bool",
                name: "success",
                type: "bool"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "actualGasCost",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "actualGasUsed",
                type: "uint256"
            }
        ],
        name: "UserOperationEvent",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "userOpHash",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "bytes",
                name: "revertReason",
                type: "bytes"
            }
        ],
        name: "UserOperationRevertReason",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: false,
                internalType: "address",
                name: "withdrawAddress",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "Withdrawn",
        type: "event"
    },
    {
        inputs: [],
        name: "SIG_VALIDATION_FAILED",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
            },
            {
                internalType: "address",
                name: "sender",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
            }
        ],
        name: "_validateSenderAndPaymaster",
        outputs: [],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint32",
                name: "unstakeDelaySec",
                type: "uint32"
            }
        ],
        name: "addStake",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "depositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "deposits",
        outputs: [
            {
                internalType: "uint112",
                name: "deposit",
                type: "uint112"
            },
            {
                internalType: "bool",
                name: "staked",
                type: "bool"
            },
            {
                internalType: "uint112",
                name: "stake",
                type: "uint112"
            },
            {
                internalType: "uint32",
                name: "unstakeDelaySec",
                type: "uint32"
            },
            {
                internalType: "uint48",
                name: "withdrawTime",
                type: "uint48"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "getDepositInfo",
        outputs: [
            {
                components: [
                    {
                        internalType: "uint112",
                        name: "deposit",
                        type: "uint112"
                    },
                    {
                        internalType: "bool",
                        name: "staked",
                        type: "bool"
                    },
                    {
                        internalType: "uint112",
                        name: "stake",
                        type: "uint112"
                    },
                    {
                        internalType: "uint32",
                        name: "unstakeDelaySec",
                        type: "uint32"
                    },
                    {
                        internalType: "uint48",
                        name: "withdrawTime",
                        type: "uint48"
                    }
                ],
                internalType: "struct IStakeManager.DepositInfo",
                name: "info",
                type: "tuple"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "sender",
                type: "address"
            },
            {
                internalType: "uint192",
                name: "key",
                type: "uint192"
            }
        ],
        name: "getNonce",
        outputs: [
            {
                internalType: "uint256",
                name: "nonce",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "initCode",
                type: "bytes"
            }
        ],
        name: "getSenderAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address"
                    },
                    {
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "initCode",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "callData",
                        type: "bytes"
                    },
                    {
                        internalType: "uint256",
                        name: "callGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "verificationGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "preVerificationGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPriorityFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterAndData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes"
                    }
                ],
                internalType: "struct UserOperation",
                name: "userOp",
                type: "tuple"
            }
        ],
        name: "getUserOpHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "sender",
                                type: "address"
                            },
                            {
                                internalType: "uint256",
                                name: "nonce",
                                type: "uint256"
                            },
                            {
                                internalType: "bytes",
                                name: "initCode",
                                type: "bytes"
                            },
                            {
                                internalType: "bytes",
                                name: "callData",
                                type: "bytes"
                            },
                            {
                                internalType: "uint256",
                                name: "callGasLimit",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "verificationGasLimit",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "preVerificationGas",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "maxFeePerGas",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "maxPriorityFeePerGas",
                                type: "uint256"
                            },
                            {
                                internalType: "bytes",
                                name: "paymasterAndData",
                                type: "bytes"
                            },
                            {
                                internalType: "bytes",
                                name: "signature",
                                type: "bytes"
                            }
                        ],
                        internalType: "struct UserOperation[]",
                        name: "userOps",
                        type: "tuple[]"
                    },
                    {
                        internalType: "contract IAggregator",
                        name: "aggregator",
                        type: "address"
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes"
                    }
                ],
                internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
                name: "opsPerAggregator",
                type: "tuple[]"
            },
            {
                internalType: "address payable",
                name: "beneficiary",
                type: "address"
            }
        ],
        name: "handleAggregatedOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address"
                    },
                    {
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "initCode",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "callData",
                        type: "bytes"
                    },
                    {
                        internalType: "uint256",
                        name: "callGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "verificationGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "preVerificationGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPriorityFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterAndData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes"
                    }
                ],
                internalType: "struct UserOperation[]",
                name: "ops",
                type: "tuple[]"
            },
            {
                internalType: "address payable",
                name: "beneficiary",
                type: "address"
            }
        ],
        name: "handleOps",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint192",
                name: "key",
                type: "uint192"
            }
        ],
        name: "incrementNonce",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "callData",
                type: "bytes"
            },
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "sender",
                                type: "address"
                            },
                            {
                                internalType: "uint256",
                                name: "nonce",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "callGasLimit",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "verificationGasLimit",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "preVerificationGas",
                                type: "uint256"
                            },
                            {
                                internalType: "address",
                                name: "paymaster",
                                type: "address"
                            },
                            {
                                internalType: "uint256",
                                name: "maxFeePerGas",
                                type: "uint256"
                            },
                            {
                                internalType: "uint256",
                                name: "maxPriorityFeePerGas",
                                type: "uint256"
                            }
                        ],
                        internalType: "struct EntryPoint.MemoryUserOp",
                        name: "mUserOp",
                        type: "tuple"
                    },
                    {
                        internalType: "bytes32",
                        name: "userOpHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint256",
                        name: "prefund",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "contextOffset",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "preOpGas",
                        type: "uint256"
                    }
                ],
                internalType: "struct EntryPoint.UserOpInfo",
                name: "opInfo",
                type: "tuple"
            },
            {
                internalType: "bytes",
                name: "context",
                type: "bytes"
            }
        ],
        name: "innerHandleOp",
        outputs: [
            {
                internalType: "uint256",
                name: "actualGasCost",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            },
            {
                internalType: "uint192",
                name: "",
                type: "uint192"
            }
        ],
        name: "nonceSequenceNumber",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address"
                    },
                    {
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "initCode",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "callData",
                        type: "bytes"
                    },
                    {
                        internalType: "uint256",
                        name: "callGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "verificationGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "preVerificationGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPriorityFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterAndData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes"
                    }
                ],
                internalType: "struct UserOperation",
                name: "op",
                type: "tuple"
            },
            {
                internalType: "address",
                name: "target",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "targetCallData",
                type: "bytes"
            }
        ],
        name: "simulateHandleOp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address"
                    },
                    {
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "initCode",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "callData",
                        type: "bytes"
                    },
                    {
                        internalType: "uint256",
                        name: "callGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "verificationGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "preVerificationGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPriorityFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterAndData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes"
                    }
                ],
                internalType: "struct UserOperation",
                name: "userOp",
                type: "tuple"
            }
        ],
        name: "simulateValidation",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "unlockStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address payable",
                name: "withdrawAddress",
                type: "address"
            }
        ],
        name: "withdrawStake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address payable",
                name: "withdrawAddress",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "withdrawAmount",
                type: "uint256"
            }
        ],
        name: "withdrawTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        stateMutability: "payable",
        type: "receive"
    }
]; //# sourceMappingURL=EntryPointAbi.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/BaseSmartContractAccount.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseSmartContractAccount",
    ()=>BaseSmartContractAccount,
    "DeploymentState",
    ()=>DeploymentState
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createPublicClient.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/actions/getContract.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/trim.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$EntryPointAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/abi/EntryPointAbi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/getChain.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Utils.js [client] (ecmascript)");
;
;
;
;
;
var DeploymentState;
(function(DeploymentState) {
    DeploymentState["UNDEFINED"] = "0x0";
    DeploymentState["NOT_DEPLOYED"] = "0x1";
    DeploymentState["DEPLOYED"] = "0x2";
})(DeploymentState || (DeploymentState = {}));
class BaseSmartContractAccount {
    constructor(params){
        Object.defineProperty(this, "factoryAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "deploymentState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: DeploymentState.UNDEFINED
        });
        Object.defineProperty(this, "accountAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "accountInitCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entryPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entryPointAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rpcProvider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * If your contract supports UUPS, you can implement this method which can be
         * used to upgrade the implementation of the account.
         *
         * @param upgradeToImplAddress -- the implementation address of the contract you want to upgrade to
         * @param upgradeToInitData -- the initialization data required by that account
         */ Object.defineProperty(this, "encodeUpgradeToAndCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (_upgradeToImplAddress, _upgradeToInitData)=>{
                throw new Error("Upgrade ToAndCall Not Supported");
            }
        });
        Object.defineProperty(this, "extend", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (fn)=>{
                const extended = fn(this);
                // this should make it so extensions can't overwrite the base methods
                for(const key in this){
                    delete extended[key];
                }
                return Object.assign(this, extended);
            }
        });
        this.entryPointAddress = params.entryPointAddress ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ENTRYPOINT_ADDRESS"];
        this.rpcProvider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createPublicClient"])({
            chain: params.viemChain ?? params.customChain ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(params.chainId),
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])(params.rpcUrl || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(params.chainId).rpcUrls.default.http[0])
        });
        this.accountAddress = params.accountAddress;
        this.factoryAddress = params.factoryAddress;
        this.signer = params.signer;
        this.accountInitCode = params.initCode;
        this.entryPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getContract"])({
            address: this.entryPointAddress,
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$EntryPointAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["EntryPointAbi"],
            client: this.rpcProvider
        });
    }
    //#endregion abstract-methods
    //#region optional-methods
    /**
     * If your account handles 1271 signatures of personal_sign differently
     * than it does UserOperations, you can implement two different approaches to signing
     *
     * @param uoHash -- The hash of the UserOperation to sign
     * @returns the signature of the UserOperation
     */ async signUserOperationHash(uoHash) {
        return this.signMessage(uoHash);
    }
    /**
     * If your contract supports signing and verifying typed data,
     * you should implement this method.
     *
     * @param _params -- Typed Data params to sign
     */ async signTypedData(_params) {
        throw new Error("signTypedData not supported");
    }
    /**
     * This method should wrap the result of `signMessage` as per
     * [EIP-6492](https://eips.ethereum.org/EIPS/eip-6492)
     *
     * @param msg -- the message to sign
     */ async signMessageWith6492(msg) {
        const [isDeployed, signature] = await Promise.all([
            this.isAccountDeployed(),
            this.signMessage(msg)
        ]);
        return this.create6492Signature(isDeployed, signature);
    }
    /**
     * Similar to the signMessageWith6492 method above,
     * this method should wrap the result of `signTypedData` as per
     * [EIP-6492](https://eips.ethereum.org/EIPS/eip-6492)
     *
     * @param params -- Typed Data params to sign
     */ async signTypedDataWith6492(// @ts-ignore
    params) {
        throw new Error("signTypedDataWith6492 not supported");
    // const [isDeployed, signature] = await Promise.all([
    //   this.isAccountDeployed(),
    //   this.signTypedData(params)
    // ])
    // return this.create6492Signature(isDeployed, signature)
    }
    /**
     * Not all contracts support batch execution.
     * If your contract does, this method should encode a list of
     * transactions into the call data that will be passed to your
     * contract's batch execution method.
     *
     * @param _txs -- the transactions to batch execute
     */ async encodeBatchExecute(_txs) {
        throw new Error("Batch execution not supported");
    }
    //#endregion optional-methods
    // Extra implementations
    async getNonce() {
        if (!await this.isAccountDeployed()) {
            return 0n;
        }
        const address = await this.getAddress();
        return this.entryPoint.read.getNonce([
            address,
            BigInt(0)
        ]);
    }
    async getInitCode() {
        if (this.deploymentState === DeploymentState.DEPLOYED) {
            return "0x";
        }
        const contractCode = await this.rpcProvider.getBytecode({
            address: await this.getAddress()
        });
        if ((contractCode?.length ?? 0) > 2) {
            this.deploymentState = DeploymentState.DEPLOYED;
            return "0x";
        }
        this.deploymentState = DeploymentState.NOT_DEPLOYED;
        return this._getAccountInitCode();
    }
    async getAddress() {
        if (!this.accountAddress) {
            const initCode = await this._getAccountInitCode();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log("[BaseSmartContractAccount](getAddress) initCode: ", initCode);
            try {
                await this.entryPoint.simulate.getSenderAddress([
                    initCode
                ]);
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log("[BaseSmartContractAccount](getAddress) getSenderAddress err: ", err);
                if (err.cause?.data?.errorName === "SenderAddressResult") {
                    this.accountAddress = err.cause.data.args[0];
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log("[BaseSmartContractAccount](getAddress) entryPoint.getSenderAddress result:", this.accountAddress);
                    return this.accountAddress;
                }
                if (err.details === "Invalid URL") {
                    throw new Error("Invalid URL");
                }
            }
            throw new Error("Failed to get counterfactual account address");
        }
        return this.accountAddress;
    }
    getSigner() {
        return this.signer;
    }
    getFactoryAddress() {
        return this.factoryAddress;
    }
    getEntryPointAddress() {
        return this.entryPointAddress;
    }
    async isAccountDeployed() {
        return await this.getDeploymentState() === DeploymentState.DEPLOYED;
    }
    async getDeploymentState() {
        if (this.deploymentState === DeploymentState.UNDEFINED) {
            const initCode = await this.getInitCode();
            return initCode === "0x" ? DeploymentState.DEPLOYED : DeploymentState.NOT_DEPLOYED;
        }
        return this.deploymentState;
    }
    /**
     * https://eips.ethereum.org/EIPS/eip-4337#first-time-account-creation
     * The initCode field (if non-zero length) is parsed as a 20-byte address,
     * followed by calldata to pass to this address.
     * The factory address is the first 40 char after the 0x, and the callData is the rest.
     */ async parseFactoryAddressFromAccountInitCode() {
        const initCode = await this._getAccountInitCode();
        const factoryAddress = `0x${initCode.substring(2, 42)}`;
        const factoryCalldata = `0x${initCode.substring(42)}`;
        return [
            factoryAddress,
            factoryCalldata
        ];
    }
    async getImplementationAddress() {
        const accountAddress = await this.getAddress();
        const storage = await this.rpcProvider.getStorageAt({
            address: accountAddress,
            // This is the default slot for the implementation address for Proxies
            slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
        });
        if (storage == null) {
            throw new Error("Failed to get storage slot 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc");
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$client$5d$__$28$ecmascript$29$__["trim"])(storage);
    }
    async _getAccountInitCode() {
        return this.accountInitCode ?? this.getAccountInitCode();
    }
    async create6492Signature(isDeployed, signature) {
        if (isDeployed) {
            return signature;
        }
        const [factoryAddress, factoryCalldata] = await this.parseFactoryAddressFromAccountInitCode();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log(`[BaseSmartContractAccount](create6492Signature)\
        factoryAddress: ${factoryAddress}, factoryCalldata: ${factoryCalldata}`);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["wrapSignatureWith6492"])({
            factoryAddress,
            factoryCalldata,
            signature
        });
    }
} //# sourceMappingURL=BaseSmartContractAccount.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/abi/AccountResolver.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AccountResolverAbi",
    ()=>AccountResolverAbi
]);
const AccountResolverAbi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_v1Factory",
                type: "address"
            },
            {
                internalType: "address",
                name: "_v2Factory",
                type: "address"
            },
            {
                internalType: "address",
                name: "_ecdsaModule",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
    },
    {
        inputs: [],
        name: "ecdsaOwnershipModule",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_eoa",
                type: "address"
            },
            {
                internalType: "uint8",
                name: "_maxIndex",
                type: "uint8"
            }
        ],
        name: "resolveAddresses",
        outputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "accountAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "factoryAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "currentImplementation",
                        type: "address"
                    },
                    {
                        internalType: "string",
                        name: "currentVersion",
                        type: "string"
                    },
                    {
                        internalType: "string",
                        name: "factoryVersion",
                        type: "string"
                    },
                    {
                        internalType: "uint256",
                        name: "deploymentIndex",
                        type: "uint256"
                    }
                ],
                internalType: "struct IAddressResolver.SmartAccountResult[]",
                name: "",
                type: "tuple[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_eoa",
                type: "address"
            },
            {
                internalType: "uint8",
                name: "_maxIndex",
                type: "uint8"
            },
            {
                internalType: "address",
                name: "_moduleAddress",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "_moduleSetupData",
                type: "bytes"
            }
        ],
        name: "resolveAddressesFlexibleForV2",
        outputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "accountAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "factoryAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "currentImplementation",
                        type: "address"
                    },
                    {
                        internalType: "string",
                        name: "currentVersion",
                        type: "string"
                    },
                    {
                        internalType: "string",
                        name: "factoryVersion",
                        type: "string"
                    },
                    {
                        internalType: "uint256",
                        name: "deploymentIndex",
                        type: "uint256"
                    }
                ],
                internalType: "struct IAddressResolver.SmartAccountResult[]",
                name: "",
                type: "tuple[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_eoa",
                type: "address"
            },
            {
                internalType: "uint8",
                name: "_maxIndex",
                type: "uint8"
            }
        ],
        name: "resolveAddressesV1",
        outputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "accountAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "factoryAddress",
                        type: "address"
                    },
                    {
                        internalType: "address",
                        name: "currentImplementation",
                        type: "address"
                    },
                    {
                        internalType: "string",
                        name: "currentVersion",
                        type: "string"
                    },
                    {
                        internalType: "string",
                        name: "factoryVersion",
                        type: "string"
                    },
                    {
                        internalType: "uint256",
                        name: "deploymentIndex",
                        type: "uint256"
                    }
                ],
                internalType: "struct IAddressResolver.SmartAccountResult[]",
                name: "",
                type: "tuple[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "smartAccountFactoryV1",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "smartAccountFactoryV2",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
]; //# sourceMappingURL=AccountResolver.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/abi/Factory.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BiconomyFactoryAbi",
    ()=>BiconomyFactoryAbi
]);
const BiconomyFactoryAbi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "initialAuthModule",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "index",
                type: "uint256"
            }
        ],
        name: "AccountCreation",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "initialAuthModule",
                type: "address"
            }
        ],
        name: "AccountCreationWithoutIndex",
        type: "event"
    },
    {
        inputs: [],
        name: "accountCreationCode",
        outputs: [
            {
                internalType: "bytes",
                name: "",
                type: "bytes"
            }
        ],
        stateMutability: "pure",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "moduleSetupContract",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "moduleSetupData",
                type: "bytes"
            }
        ],
        name: "deployAccount",
        outputs: [
            {
                internalType: "address",
                name: "proxy",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "moduleSetupContract",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "moduleSetupData",
                type: "bytes"
            },
            {
                internalType: "uint256",
                name: "index",
                type: "uint256"
            }
        ],
        name: "deployCounterFactualAccount",
        outputs: [
            {
                internalType: "address",
                name: "proxy",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "moduleSetupContract",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "moduleSetupData",
                type: "bytes"
            },
            {
                internalType: "uint256",
                name: "index",
                type: "uint256"
            }
        ],
        name: "getAddressForCounterFactualAccount",
        outputs: [
            {
                internalType: "address",
                name: "_account",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
]; //# sourceMappingURL=Factory.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/abi/SmartAccount.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BiconomyAccountAbi",
    ()=>BiconomyAccountAbi
]);
const BiconomyAccountAbi = [
    {
        inputs: [
            {
                internalType: "contract IEntryPoint",
                name: "anEntryPoint",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
    },
    {
        inputs: [],
        name: "AlreadyInitialized",
        type: "error"
    },
    {
        inputs: [],
        name: "BaseImplementationCannotBeZero",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "caller",
                type: "address"
            }
        ],
        name: "CallerIsNotAnEntryPoint",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "caller",
                type: "address"
            }
        ],
        name: "CallerIsNotEntryPoint",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "caller",
                type: "address"
            }
        ],
        name: "CallerIsNotEntryPointOrOwner",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "caller",
                type: "address"
            }
        ],
        name: "CallerIsNotEntryPointOrSelf",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "caller",
                type: "address"
            }
        ],
        name: "CallerIsNotOwner",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "caller",
                type: "address"
            }
        ],
        name: "CallerIsNotSelf",
        type: "error"
    },
    {
        inputs: [],
        name: "DelegateCallsOnly",
        type: "error"
    },
    {
        inputs: [],
        name: "EntryPointCannotBeZero",
        type: "error"
    },
    {
        inputs: [],
        name: "HandlerCannotBeZero",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "implementationAddress",
                type: "address"
            }
        ],
        name: "InvalidImplementation",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "caller",
                type: "address"
            }
        ],
        name: "MixedAuthFail",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "ModuleAlreadyEnabled",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "expectedModule",
                type: "address"
            },
            {
                internalType: "address",
                name: "returnedModule",
                type: "address"
            },
            {
                internalType: "address",
                name: "prevModule",
                type: "address"
            }
        ],
        name: "ModuleAndPrevModuleMismatch",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "ModuleCannotBeZeroOrSentinel",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "ModuleNotEnabled",
        type: "error"
    },
    {
        inputs: [],
        name: "ModulesAlreadyInitialized",
        type: "error"
    },
    {
        inputs: [],
        name: "ModulesSetupExecutionFailed",
        type: "error"
    },
    {
        inputs: [],
        name: "OwnerCanNotBeSelf",
        type: "error"
    },
    {
        inputs: [],
        name: "OwnerCannotBeZero",
        type: "error"
    },
    {
        inputs: [],
        name: "OwnerProvidedIsSame",
        type: "error"
    },
    {
        inputs: [],
        name: "TransferToZeroAddressAttempt",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "destLength",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "valueLength",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "funcLength",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "operationLength",
                type: "uint256"
            }
        ],
        name: "WrongBatchProvided",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "contractSignature",
                type: "bytes"
            }
        ],
        name: "WrongContractSignature",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "uintS",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "contractSignatureLength",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "signatureLength",
                type: "uint256"
            }
        ],
        name: "WrongContractSignatureFormat",
        type: "error"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "moduleAddressProvided",
                type: "address"
            }
        ],
        name: "WrongValidationModule",
        type: "error"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "previousHandler",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "handler",
                type: "address"
            }
        ],
        name: "ChangedFallbackHandler",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "DisabledModule",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "EnabledModule",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes",
                name: "data",
                type: "bytes"
            },
            {
                indexed: false,
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "txGas",
                type: "uint256"
            }
        ],
        name: "ExecutionFailure",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "ExecutionFromModuleFailure",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "ExecutionFromModuleSuccess",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes",
                name: "data",
                type: "bytes"
            },
            {
                indexed: false,
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "txGas",
                type: "uint256"
            }
        ],
        name: "ExecutionSuccess",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "oldImplementation",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "newImplementation",
                type: "address"
            }
        ],
        name: "ImplementationUpdated",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "module",
                type: "address"
            },
            {
                indexed: false,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "bytes",
                name: "data",
                type: "bytes"
            },
            {
                indexed: false,
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
            }
        ],
        name: "ModuleTransaction",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "sender",
                type: "address"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "value",
                type: "uint256"
            }
        ],
        name: "SmartAccountReceivedNativeToken",
        type: "event"
    },
    {
        stateMutability: "nonpayable",
        type: "fallback"
    },
    {
        inputs: [],
        name: "VERSION",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "addDeposit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "prevModule",
                type: "address"
            },
            {
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "disableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "enableModule",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "entryPoint",
        outputs: [
            {
                internalType: "contract IEntryPoint",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "to",
                type: "address[]"
            },
            {
                internalType: "uint256[]",
                name: "value",
                type: "uint256[]"
            },
            {
                internalType: "bytes[]",
                name: "data",
                type: "bytes[]"
            },
            {
                internalType: "enum Enum.Operation[]",
                name: "operations",
                type: "uint8[]"
            }
        ],
        name: "execBatchTransactionFromModule",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes"
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
            },
            {
                internalType: "uint256",
                name: "txGas",
                type: "uint256"
            }
        ],
        name: "execTransactionFromModule",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes"
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
            }
        ],
        name: "execTransactionFromModule",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "data",
                type: "bytes"
            },
            {
                internalType: "enum Enum.Operation",
                name: "operation",
                type: "uint8"
            }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
            {
                internalType: "bool",
                name: "success",
                type: "bool"
            },
            {
                internalType: "bytes",
                name: "returnData",
                type: "bytes"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "dest",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "func",
                type: "bytes"
            }
        ],
        name: "execute",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "dest",
                type: "address[]"
            },
            {
                internalType: "uint256[]",
                name: "value",
                type: "uint256[]"
            },
            {
                internalType: "bytes[]",
                name: "func",
                type: "bytes[]"
            }
        ],
        name: "executeBatch",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "dest",
                type: "address[]"
            },
            {
                internalType: "uint256[]",
                name: "value",
                type: "uint256[]"
            },
            {
                internalType: "bytes[]",
                name: "func",
                type: "bytes[]"
            }
        ],
        name: "executeBatch_y6U",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "dest",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "value",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "func",
                type: "bytes"
            }
        ],
        name: "execute_ncC",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "getDeposit",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getFallbackHandler",
        outputs: [
            {
                internalType: "address",
                name: "_handler",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getImplementation",
        outputs: [
            {
                internalType: "address",
                name: "_implementation",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "start",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "pageSize",
                type: "uint256"
            }
        ],
        name: "getModulesPaginated",
        outputs: [
            {
                internalType: "address[]",
                name: "array",
                type: "address[]"
            },
            {
                internalType: "address",
                name: "next",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "handler",
                type: "address"
            },
            {
                internalType: "address",
                name: "moduleSetupContract",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "moduleSetupData",
                type: "bytes"
            }
        ],
        name: "init",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "module",
                type: "address"
            }
        ],
        name: "isModuleEnabled",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "dataHash",
                type: "bytes32"
            },
            {
                internalType: "bytes",
                name: "signature",
                type: "bytes"
            }
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint192",
                name: "_key",
                type: "uint192"
            }
        ],
        name: "nonce",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        name: "noncesDeprecated",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "ownerDeprecated",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "handler",
                type: "address"
            }
        ],
        name: "setFallbackHandler",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "setupContract",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "setupData",
                type: "bytes"
            }
        ],
        name: "setupAndEnableModule",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "_interfaceId",
                type: "bytes4"
            }
        ],
        name: "supportsInterface",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_implementation",
                type: "address"
            }
        ],
        name: "updateImplementation",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address"
                    },
                    {
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "initCode",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "callData",
                        type: "bytes"
                    },
                    {
                        internalType: "uint256",
                        name: "callGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "verificationGasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "preVerificationGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPriorityFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterAndData",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes"
                    }
                ],
                internalType: "struct UserOperation",
                name: "userOp",
                type: "tuple"
            },
            {
                internalType: "bytes32",
                name: "userOpHash",
                type: "bytes32"
            },
            {
                internalType: "uint256",
                name: "missingAccountFunds",
                type: "uint256"
            }
        ],
        name: "validateUserOp",
        outputs: [
            {
                internalType: "uint256",
                name: "validationData",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address payable",
                name: "withdrawAddress",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "withdrawDepositTo",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    },
    {
        stateMutability: "payable",
        type: "receive"
    }
]; //# sourceMappingURL=SmartAccount.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/BiconomySmartAccountV2.js [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BiconomySmartAccountV2",
    ()=>BiconomySmartAccountV2
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createPublicClient.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$decodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/decodeFunctionData.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeFunctionData.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodePacked$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodePacked.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/unit/formatUnits.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/actions/getContract.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getContractAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getContractAddress.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toBytes.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$taikoHekla$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/taikoHekla.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$Bundler$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/Bundler.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/bundler/utils/Utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/BaseValidationModule.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$sessions$2f$batch$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/sessions/batch.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$sessions$2f$abi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/sessions/abi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/modules/session-storage/utils.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$BiconomyPaymaster$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/paymaster/BiconomyPaymaster.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/paymaster/index.js [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/paymaster/utils/Types.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Logger.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/convertSigner.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/getChain.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$BaseSmartContractAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/BaseSmartContractAccount.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$AccountResolver$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/abi/AccountResolver.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$Factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/abi/Factory.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/abi/SmartAccount.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Constants.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/utils/Utils.js [client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
class BiconomySmartAccountV2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$BaseSmartContractAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseSmartContractAccount"] {
    constructor(biconomySmartAccountConfig){
        const chain = biconomySmartAccountConfig.viemChain ?? biconomySmartAccountConfig.customChain ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(biconomySmartAccountConfig.chainId);
        const rpcClient = biconomySmartAccountConfig.rpcUrl || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(biconomySmartAccountConfig.chainId).rpcUrls.default.http[0];
        const defaultedFactoryAddress = chain?.id === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$taikoHekla$2e$js__$5b$client$5d$__$28$ecmascript$29$__["taikoHekla"].id ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TAIKO_FACTORY_ADDRESS"] : biconomySmartAccountConfig.factoryAddress ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_BICONOMY_FACTORY_ADDRESS"];
        const isDefaultFactory = [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_BICONOMY_FACTORY_ADDRESS"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TAIKO_FACTORY_ADDRESS"]
        ].some((address)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["addressEquals"])(defaultedFactoryAddress, address));
        super({
            ...biconomySmartAccountConfig,
            chain,
            rpcClient,
            entryPointAddress: biconomySmartAccountConfig.entryPointAddress ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_ENTRYPOINT_ADDRESS"],
            accountAddress: biconomySmartAccountConfig.accountAddress ?? undefined,
            factoryAddress: defaultedFactoryAddress
        });
        Object.defineProperty(this, "biconomySmartAccountConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: biconomySmartAccountConfig
        });
        Object.defineProperty(this, "sessionData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sessionType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "sessionStorageClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "SENTINEL_MODULE", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "0x0000000000000000000000000000000000000001"
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "chainId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "paymaster", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "bundler", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "accountContract", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "defaultFallbackHandlerAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "implementationAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scanForUpgradedAccountsFromV1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxIndexForScan", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Validation module responsible for account deployment initCode. This acts as a default authorization module.
        Object.defineProperty(this, "defaultValidationModule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Deployed Smart Account can have more than one module enabled. When sending a transaction activeValidationModule is used to prepare and validate userOp signature.
        Object.defineProperty(this, "activeValidationModule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.sessionData = biconomySmartAccountConfig.sessionData;
        this.sessionType = biconomySmartAccountConfig.sessionType ?? null;
        this.defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;
        this.activeValidationModule = biconomySmartAccountConfig.activeValidationModule;
        this.index = biconomySmartAccountConfig.index ?? 0;
        this.chainId = biconomySmartAccountConfig.chainId;
        this.bundler = biconomySmartAccountConfig.bundler;
        this.implementationAddress = biconomySmartAccountConfig.implementationAddress ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BICONOMY_IMPLEMENTATION_ADDRESSES_BY_VERSION"].V2_0_0;
        if (biconomySmartAccountConfig.paymasterUrl) {
            this.paymaster = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Paymaster"]({
                paymasterUrl: biconomySmartAccountConfig.paymasterUrl
            });
        } else if (biconomySmartAccountConfig.biconomyPaymasterApiKey) {
            this.paymaster = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Paymaster"]({
                paymasterUrl: `https://paymaster.biconomy.io/api/v1/${biconomySmartAccountConfig.chainId}/${biconomySmartAccountConfig.biconomyPaymasterApiKey}`
            });
        } else {
            this.paymaster = biconomySmartAccountConfig.paymaster;
        }
        this.bundler = biconomySmartAccountConfig.bundler;
        const defaultFallbackHandlerAddress = isDefaultFactory ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_FALLBACK_HANDLER_ADDRESS"] : biconomySmartAccountConfig.defaultFallbackHandler;
        if (!defaultFallbackHandlerAddress) {
            throw new Error("Default Fallback Handler address is not provided");
        }
        this.defaultFallbackHandlerAddress = defaultFallbackHandlerAddress;
        // Added bang operator to avoid null check as the constructor have these params as optional
        this.defaultValidationModule = // biome-ignore lint/style/noNonNullAssertion: <explanation>
        biconomySmartAccountConfig.defaultValidationModule;
        this.activeValidationModule = // biome-ignore lint/style/noNonNullAssertion: <explanation>
        biconomySmartAccountConfig.activeValidationModule;
        this.provider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createPublicClient"])({
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$client$5d$__$28$ecmascript$29$__["http"])(rpcClient)
        });
        this.scanForUpgradedAccountsFromV1 = biconomySmartAccountConfig.scanForUpgradedAccountsFromV1 ?? false;
        this.maxIndexForScan = biconomySmartAccountConfig.maxIndexForScan ?? 10;
        this.getAccountAddress();
        this.sessionStorageClient = biconomySmartAccountConfig.sessionStorageClient;
    }
    /**
     * Creates a new instance of BiconomySmartAccountV2
     *
     * This method will create a BiconomySmartAccountV2 instance but will not deploy the Smart Account
     * Deployment of the Smart Account will be donewith the first user operation.
     *
     * - Docs: https://docs.biconomy.io/Account/integration#integration-1
     *
     * @param biconomySmartAccountConfig - Configuration for initializing the BiconomySmartAccountV2 instance {@link BiconomySmartAccountV2Config}.
     * @returns A promise that resolves to a new instance of BiconomySmartAccountV2.
     * @throws An error if something is wrong with the smart account instance creation.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient, BiconomySmartAccountV2 } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const bundlerUrl = "" // Retrieve bundler url from dashboard
     *
     * const smartAccountFromStaticCreate = await BiconomySmartAccountV2.create({ signer, bundlerUrl });
     *
     * // Is the same as...
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl });
     *
     */ static async create(biconomySmartAccountConfig) {
        let chainId = biconomySmartAccountConfig.chainId;
        let rpcUrl = biconomySmartAccountConfig.customChain?.rpcUrls?.default?.http?.[0] ?? biconomySmartAccountConfig.rpcUrl;
        let resolvedSmartAccountSigner;
        // Signer needs to be initialised here before defaultValidationModule is set
        if (biconomySmartAccountConfig.signer) {
            const signerResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$convertSigner$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertSigner"])(biconomySmartAccountConfig.signer, !!chainId, rpcUrl);
            if (!chainId && !!signerResult.chainId) {
                chainId = signerResult.chainId;
            }
            if (!rpcUrl && !!signerResult.rpcUrl) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isValidRpcUrl"])(signerResult.rpcUrl)) {
                    rpcUrl = signerResult.rpcUrl;
                }
            }
            resolvedSmartAccountSigner = signerResult.signer;
        }
        if (!chainId) {
            // Get it from bundler
            if (biconomySmartAccountConfig.bundlerUrl) {
                chainId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractChainIdFromBundlerUrl"])(biconomySmartAccountConfig.bundlerUrl);
            } else if (biconomySmartAccountConfig.bundler) {
                const bundlerUrlFromBundler = biconomySmartAccountConfig.bundler.getBundlerUrl();
                chainId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["extractChainIdFromBundlerUrl"])(bundlerUrlFromBundler);
            }
        }
        if (!chainId) {
            throw new Error("chainId required");
        }
        const bundler = biconomySmartAccountConfig.bundler ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$bundler$2f$Bundler$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Bundler"]({
            // biome-ignore lint/style/noNonNullAssertion: always required
            bundlerUrl: biconomySmartAccountConfig.bundlerUrl,
            chainId,
            customChain: biconomySmartAccountConfig.viemChain ?? biconomySmartAccountConfig.customChain ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(chainId)
        });
        let defaultValidationModule = biconomySmartAccountConfig.defaultValidationModule;
        // Note: If no module is provided, we will use ECDSA_OWNERSHIP as default
        if (!defaultValidationModule) {
            const newModule = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createECDSAOwnershipValidationModule"])({
                // biome-ignore lint/style/noNonNullAssertion: <explanation>
                signer: resolvedSmartAccountSigner
            });
            defaultValidationModule = newModule;
        }
        const activeValidationModule = biconomySmartAccountConfig?.activeValidationModule ?? defaultValidationModule;
        if (!resolvedSmartAccountSigner) {
            resolvedSmartAccountSigner = await activeValidationModule.getSigner();
        }
        if (!resolvedSmartAccountSigner) {
            throw new Error("signer required");
        }
        const config = {
            ...biconomySmartAccountConfig,
            defaultValidationModule,
            activeValidationModule,
            chainId,
            bundler,
            signer: resolvedSmartAccountSigner,
            rpcUrl
        };
        // We check if chain ids match (skip this if chainId is passed by in the config)
        // This check is at the end of the function for cases when the signer is not passed in the config but a validation modules is and we get the signer from the validation module in this case
        if (biconomySmartAccountConfig.skipChainCheck !== true && !biconomySmartAccountConfig.chainId) {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["compareChainIds"])(biconomySmartAccountConfig.signer || resolvedSmartAccountSigner, config, false);
        }
        return new BiconomySmartAccountV2(config);
    }
    // Calls the getCounterFactualAddress
    async getAddress(params) {
        if (this.accountAddress == null) {
            // means it needs deployment
            this.accountAddress = await this.getCounterFactualAddress(params);
        }
        return this.accountAddress;
    }
    // Calls the getCounterFactualAddress
    async getAccountAddress(params) {
        if (this.accountAddress == null || this.accountAddress === undefined) {
            // means it needs deployment
            this.accountAddress = await this.getCounterFactualAddress(params);
        }
        return this.accountAddress;
    }
    /**
     * Returns an upper estimate for the gas spent on a specific user operation
     *
     * This method will fetch an approximate gas estimate for the user operation, given the current state of the network.
     * It is regularly an overestimate, and the actual gas spent will likely be lower.
     * It is unlikely to be an underestimate unless the network conditions rapidly change.
     *
     * @param transactions Array of {@link Transaction} to be sent.
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @returns Promise<bigint> - The estimated gas cost in wei.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl, paymasterUrl }); // Retrieve bundler/paymaster url from dashboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const tx = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const amountInWei = await smartAccount.getGasEstimates([tx, tx], {
     *    paymasterServiceData: {
     *      mode: PaymasterMode.SPONSORED,
     *    },
     * });
     *
     * console.log(amountInWei.toString());
     *
     */ async getGasEstimate(transactions, buildUseropDto) {
        const { callGasLimit, preVerificationGas, verificationGasLimit, maxFeePerGas } = await this.buildUserOp(transactions, buildUseropDto);
        const _callGasLimit = BigInt(callGasLimit || 0);
        const _preVerificationGas = BigInt(preVerificationGas || 0);
        const _verificationGasLimit = BigInt(verificationGasLimit || 0);
        const _maxFeePerGas = BigInt(maxFeePerGas || 0);
        if (!buildUseropDto?.paymasterServiceData?.mode) {
            return (_callGasLimit + _preVerificationGas + _verificationGasLimit) * _maxFeePerGas;
        }
        return (_callGasLimit + BigInt(3) * _verificationGasLimit + _preVerificationGas) * _maxFeePerGas;
    }
    /**
     * Returns balances for the smartAccount instance.
     *
     * This method will fetch tokens info given an array of token addresses for the smartAccount instance.
     * The balance of the native token will always be returned as the last element in the reponse array, with the address set to 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE.
     *
     * @param addresses - Optional. Array of asset addresses to fetch the balances of. If not provided, the method will return only the balance of the native token.
     * @returns Promise<Array<BalancePayload>> - An array of token balances (plus the native token balance) of the smartAccount instance.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const token = "0x747A4168DB14F57871fa8cda8B5455D8C2a8e90a";
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl });
     * const [tokenBalanceFromSmartAccount, nativeTokenBalanceFromSmartAccount] = await smartAccount.getBalances([token]);
     *
     * console.log(tokenBalanceFromSmartAccount);
     * // {
     * //   amount: 1000000000000000n,
     * //   decimals: 6,
     * //   address: "0x747A4168DB14F57871fa8cda8B5455D8C2a8e90a",
     * //   formattedAmount: "1000000",
     * //   chainId: 80002
     * // }
     *
     * // or to get the nativeToken balance
     *
     * const [nativeTokenBalanceFromSmartAccount] = await smartAccount.getBalances();
     *
     * console.log(nativeTokenBalanceFromSmartAccount);
     * // {
     * //   amount: 1000000000000000n,
     * //   decimals: 18,
     * //   address: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",
     * //   formattedAmount: "1",
     * //   chainId: 80002
     * // }
     *
     */ async getBalances(addresses) {
        const accountAddress = await this.getAccountAddress();
        const result = [];
        if (addresses) {
            const tokenContracts = addresses.map((address)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getContract"])({
                    address,
                    abi: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbi"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERC20_ABI"]),
                    client: this.provider
                }));
            const balancePromises = tokenContracts.map((tokenContract)=>tokenContract.read.balanceOf([
                    accountAddress
                ]));
            const decimalsPromises = tokenContracts.map((tokenContract)=>tokenContract.read.decimals());
            const [balances, decimalsPerToken] = await Promise.all([
                Promise.all(balancePromises),
                Promise.all(decimalsPromises)
            ]);
            balances.forEach((amount, index)=>result.push({
                    amount,
                    decimals: decimalsPerToken[index],
                    address: addresses[index],
                    formattedAmount: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatUnits"])(amount, decimalsPerToken[index]),
                    chainId: this.chainId
                }));
        }
        const balance = await this.provider.getBalance({
            address: accountAddress
        });
        result.push({
            amount: balance,
            decimals: 18,
            address: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NATIVE_TOKEN_ALIAS"],
            formattedAmount: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$client$5d$__$28$ecmascript$29$__["formatUnits"])(balance, 18),
            chainId: this.chainId
        });
        return result;
    }
    /**
     * Transfers funds from Smart Account to recipient (usually EOA)
     * @param recipient - Address of the recipient
     * @param withdrawalRequests - Array of withdrawal requests {@link WithdrawalRequest}. If withdrawal request is an empty array, it will transfer the balance of the native token. Using a paymaster will ensure no dust remains in the smart account.
     * @param buildUseropDto - Optional. {@link BuildUserOpOptions}
     *
     * @returns Promise<UserOpResponse> - An object containing the status of the transaction.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient, NATIVE_TOKEN_ALIAS } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonMumbai } from "viem/chains";
     *
     * const token = "0x747A4168DB14F57871fa8cda8B5455D8C2a8e90a";
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonMumbai,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl, biconomyPaymasterApiKey });
     *
     * const { wait } = await smartAccount.withdraw(
     *  [
     *    { address: token }, // omit the amount to withdraw the full balance
     *    { address: NATIVE_TOKEN_ALIAS, amount: 1n }
     *  ],
     *  account.address, // Default recipient used if no recipient is present in the withdrawal request
     *  {
     *    paymasterServiceData: { mode: PaymasterMode.SPONSORED },
     *  }
     * );
     *
     * // OR to withdraw all of the native token, leaving no dust in the smart account
     *
     * const { wait } = await smartAccount.withdraw([], account.address, {
     *  paymasterServiceData: { mode: PaymasterMode.SPONSORED },
     * });
     *
     * const { success } = await wait();
     */ async withdraw(withdrawalRequests, defaultRecipient, buildUseropDto) {
        const accountAddress = this.accountAddress ?? await this.getAccountAddress();
        if (!defaultRecipient && withdrawalRequests?.some(({ recipient })=>!recipient)) {
            throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].NO_RECIPIENT);
        }
        // Remove the native token from the withdrawal requests
        let tokenRequests = withdrawalRequests?.filter(({ address })=>!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["addressEquals"])(address, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NATIVE_TOKEN_ALIAS"])) ?? [];
        // Check if the amount is not present in all withdrawal requests
        const shouldFetchMaxBalances = tokenRequests.some(({ amount })=>!amount);
        // Get the balances of the tokens if the amount is not present in the withdrawal requests
        if (shouldFetchMaxBalances) {
            const balances = await this.getBalances(tokenRequests.map(({ address })=>address));
            tokenRequests = tokenRequests.map(({ amount, address }, i)=>({
                    address,
                    amount: amount ?? balances[i].amount
                }));
        }
        // Create the transactions
        const txs = tokenRequests.map(({ address, amount, recipient: recipientFromRequest })=>({
                to: address,
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
                    abi: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbi"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERC20_ABI"]),
                    functionName: "transfer",
                    args: [
                        recipientFromRequest || defaultRecipient,
                        amount
                    ]
                })
            }));
        // Check if eth alias is present in the original withdrawal requests
        const nativeTokenRequest = withdrawalRequests?.find(({ address })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["addressEquals"])(address, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["NATIVE_TOKEN_ALIAS"]));
        const hasNoRequests = !withdrawalRequests?.length;
        if (!!nativeTokenRequest || hasNoRequests) {
            // Check that an amount is present in the withdrawal request, if no paymaster service data is present, as max amounts cannot be calculated without a paymaster.
            if (!nativeTokenRequest?.amount && !buildUseropDto?.paymasterServiceData?.mode) {
                throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].NATIVE_TOKEN_WITHDRAWAL_WITHOUT_AMOUNT);
            }
            // get eth balance if not present in withdrawal requests
            const nativeTokenAmountToWithdraw = nativeTokenRequest?.amount ?? await this.provider.getBalance({
                address: accountAddress
            });
            txs.push({
                to: nativeTokenRequest?.recipient ?? defaultRecipient,
                value: nativeTokenAmountToWithdraw
            });
        }
        return this.sendTransaction(txs, buildUseropDto);
    }
    /**
     * Return the account's address. This value is valid even before deploying the contract.
     */ async getCounterFactualAddress(params) {
        const validationModule = params?.validationModule ?? this.defaultValidationModule;
        const index = params?.index ?? this.index;
        const maxIndexForScan = params?.maxIndexForScan ?? this.maxIndexForScan;
        // Review: default behavior
        const scanForUpgradedAccountsFromV1 = params?.scanForUpgradedAccountsFromV1 ?? this.scanForUpgradedAccountsFromV1;
        // if it's intended to detect V1 upgraded accounts
        if (scanForUpgradedAccountsFromV1) {
            const eoaSigner = await validationModule.getSigner();
            const eoaAddress = await eoaSigner.getAddress();
            const moduleAddress = validationModule.getAddress();
            const moduleSetupData = await validationModule.getInitData();
            const queryParams = {
                eoaAddress,
                index,
                moduleAddress,
                moduleSetupData,
                maxIndexForScan
            };
            const accountAddress = await this.getV1AccountsUpgradedToV2(queryParams);
            if (accountAddress !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_ZERO"]) {
                return accountAddress;
            }
        }
        const counterFactualAddressV2 = await this.getCounterFactualAddressV2({
            validationModule,
            index
        });
        return counterFactualAddressV2;
    }
    async getCounterFactualAddressV2(params) {
        const validationModule = params?.validationModule ?? this.defaultValidationModule;
        const index = params?.index ?? this.index;
        try {
            const owner = validationModule.getAddress();
            const moduleSetupData = await validationModule.getInitData();
            if (this.chainId === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$taikoHekla$2e$js__$5b$client$5d$__$28$ecmascript$29$__["taikoHekla"].id) {
                const factoryContract = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getContract"])({
                    address: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["TAIKO_FACTORY_ADDRESS"],
                    abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$Factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyFactoryAbi"],
                    client: {
                        public: this.provider,
                        wallet: this.getSigner()
                    }
                });
                const smartAccountAddressFromContracts = await factoryContract.read.getAddressForCounterFactualAccount([
                    owner,
                    moduleSetupData,
                    BigInt(index)
                ]);
                return smartAccountAddressFromContracts;
            }
            const initCalldata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
                abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
                functionName: "init",
                args: [
                    this.defaultFallbackHandlerAddress,
                    owner,
                    moduleSetupData
                ]
            });
            const proxyCreationCodeHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodePacked$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodePacked"])([
                "bytes",
                "uint256"
            ], [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PROXY_CREATION_CODE"],
                BigInt(this.implementationAddress)
            ]));
            const salt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodePacked$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodePacked"])([
                "bytes32",
                "uint256"
            ], [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(initCalldata),
                BigInt(index)
            ]));
            const counterFactualAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getContractAddress$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getCreate2Address"])({
                from: this.factoryAddress,
                salt: salt,
                bytecodeHash: proxyCreationCodeHash
            });
            return counterFactualAddress;
        } catch (e) {
            throw new Error(`Failed to get counterfactual address, ${e}`);
        }
    }
    async _getAccountContract() {
        if (this.accountContract == null) {
            this.accountContract = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getContract"])({
                address: await this.getAddress(),
                abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
                client: this.provider
            });
        }
        return this.accountContract;
    }
    isActiveValidationModuleDefined() {
        if (!this.activeValidationModule) throw new Error("Must provide an instance of active validation module.");
        return true;
    }
    isDefaultValidationModuleDefined() {
        if (!this.defaultValidationModule) throw new Error("Must provide an instance of default validation module.");
        return true;
    }
    setActiveValidationModule(validationModule) {
        if (validationModule instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseValidationModule"]) {
            this.activeValidationModule = validationModule;
        }
        return this;
    }
    setDefaultValidationModule(validationModule) {
        if (validationModule instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$BaseValidationModule$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BaseValidationModule"]) {
            this.defaultValidationModule = validationModule;
        }
        return this;
    }
    async getV1AccountsUpgradedToV2(params) {
        const maxIndexForScan = params.maxIndexForScan ?? this.maxIndexForScan;
        const addressResolver = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getContract"])({
            address: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_RESOLVER_ADDRESS"],
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$AccountResolver$2e$js__$5b$client$5d$__$28$ecmascript$29$__["AccountResolverAbi"],
            client: {
                public: this.provider
            }
        });
        // Note: depending on moduleAddress and moduleSetupData passed call this. otherwise could call resolveAddresses()
        if (params.moduleAddress && params.moduleSetupData) {
            const result = await addressResolver.read.resolveAddressesFlexibleForV2([
                params.eoaAddress,
                maxIndexForScan,
                params.moduleAddress,
                params.moduleSetupData
            ]);
            const desiredV1Account = result.find((smartAccountInfo)=>smartAccountInfo.factoryVersion === "v1" && smartAccountInfo.currentVersion === "2.0.0" && Number(smartAccountInfo.deploymentIndex.toString()) === params.index);
            if (desiredV1Account) {
                const smartAccountAddress = desiredV1Account.accountAddress;
                return smartAccountAddress;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_ZERO"];
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_ZERO"];
    }
    /**
     * Return the value to put into the "initCode" field, if the account is not yet deployed.
     * This value holds the "factory" address, followed by this account's information
     */ async getAccountInitCode() {
        this.isDefaultValidationModuleDefined();
        if (await this.isAccountDeployed()) return "0x";
        const factoryData = await this.getFactoryData();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concatHex"])([
            this.factoryAddress,
            factoryData
        ]);
    }
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns encoded data for execute function
     */ async encodeExecute(to, value, data) {
        // return accountContract.interface.encodeFunctionData("execute_ncC", [to, value, data]) as Hex;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
            functionName: "execute_ncC",
            args: [
                to,
                value,
                data
            ]
        });
    }
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns encoded data for executeBatch function
     */ async encodeExecuteBatch(to, value, data) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
            functionName: "executeBatch_y6U",
            args: [
                to,
                value,
                data
            ]
        });
    }
    async encodeBatchExecute(txs) {
        const [targets, datas, value] = txs.reduce((accum, curr)=>{
            accum[0].push(curr.target);
            accum[1].push(curr.data);
            accum[2].push(curr.value || BigInt(0));
            return accum;
        }, [
            [],
            [],
            []
        ]);
        return this.encodeExecuteBatch(targets, value, datas);
    }
    // dummy signature depends on the validation module supplied.
    async getDummySignatures(params) {
        const defaultedParams = {
            ...this.sessionData ? this.sessionData : {},
            ...params
        };
        this.isActiveValidationModuleDefined();
        return await this.activeValidationModule.getDummySignature(defaultedParams);
    }
    // TODO: review this
    getDummySignature() {
        throw new Error("Method not implemented! Call getDummySignatures instead.");
    }
    // Might use provided paymaster instance to get dummy data (from pm service)
    getDummyPaymasterData() {
        return "0x";
    }
    validateUserOp(userOp, requiredFields) {
        for (const field of requiredFields){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNullOrUndefined"])(userOp[field])) {
                throw new Error(`${String(field)} is missing in the UserOp`);
            }
        }
        return true;
    }
    async signUserOp(userOp, params) {
        const defaultedParams = {
            ...this.sessionData ? this.sessionData : {},
            ...params,
            rawUserOperation: userOp
        };
        this.isActiveValidationModuleDefined();
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData"
        ];
        this.validateUserOp(userOp, requiredFields);
        const userOpHash = await this.getUserOpHash(userOp);
        const moduleSig = await this.activeValidationModule.signUserOpHash(userOpHash, defaultedParams);
        const signatureWithModuleAddress = this.getSignatureWithModuleAddress(moduleSig, this.activeValidationModule.getAddress());
        userOp.signature = signatureWithModuleAddress;
        return userOp;
    }
    getSignatureWithModuleAddress(moduleSignature, moduleAddress) {
        const moduleAddressToUse = moduleAddress ?? this.activeValidationModule.getAddress();
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("bytes, address"), [
            moduleSignature,
            moduleAddressToUse
        ]);
        return result;
    }
    async getPaymasterUserOp(userOp, paymasterServiceData) {
        if (paymasterServiceData.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].SPONSORED) {
            return this.getPaymasterAndData(userOp, paymasterServiceData);
        }
        if (paymasterServiceData.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].ERC20) {
            if (paymasterServiceData?.feeQuote) {
                const { feeQuote, spender, maxApproval = false } = paymasterServiceData;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log("there is a feeQuote: ", JSON.stringify(feeQuote, null, 2));
                if (!spender) throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].SPENDER_REQUIRED);
                if (!feeQuote) throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].FAILED_FEE_QUOTE_FETCH);
                if (paymasterServiceData.skipPatchCallData && paymasterServiceData.skipPatchCallData === true) {
                    return this.getPaymasterAndData(userOp, {
                        ...paymasterServiceData,
                        feeTokenAddress: feeQuote.tokenAddress
                    });
                }
                const partialUserOp = await this.buildTokenPaymasterUserOp(userOp, {
                    ...paymasterServiceData,
                    spender,
                    maxApproval,
                    feeQuote
                });
                return this.getPaymasterAndData(partialUserOp, {
                    ...paymasterServiceData,
                    feeTokenAddress: feeQuote.tokenAddress,
                    calculateGasLimits: paymasterServiceData.calculateGasLimits ?? true
                });
            }
            if (paymasterServiceData?.preferredToken) {
                const { preferredToken } = paymasterServiceData;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log("there is a preferred token: ", preferredToken);
                const feeQuotesResponse = await this.getPaymasterFeeQuotesOrData(userOp, paymasterServiceData);
                const spender = feeQuotesResponse.tokenPaymasterAddress;
                const feeQuote = feeQuotesResponse.feeQuotes?.[0];
                if (!spender) throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].SPENDER_REQUIRED);
                if (!feeQuote) throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].FAILED_FEE_QUOTE_FETCH);
                return this.getPaymasterUserOp(userOp, {
                    ...paymasterServiceData,
                    feeQuote,
                    spender
                }); // Recursively call getPaymasterUserOp with the feeQuote
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log("ERC20 mode without feeQuote or preferredToken provided. Passing through unchanged.");
            return userOp;
        }
        throw new Error("Invalid paymaster mode");
    }
    async getPaymasterAndData(userOp, paymasterServiceData) {
        const paymaster = this.paymaster;
        const paymasterData = await paymaster.getPaymasterAndData(userOp, paymasterServiceData);
        return {
            ...userOp,
            ...paymasterData
        };
    }
    async getPaymasterFeeQuotesOrData(userOp, feeQuotesOrData) {
        const paymaster = this.paymaster;
        const tokenList = feeQuotesOrData?.preferredToken ? [
            feeQuotesOrData?.preferredToken
        ] : feeQuotesOrData?.tokenList?.length ? feeQuotesOrData?.tokenList : [];
        return paymaster.getPaymasterFeeQuotesOrData(userOp, {
            ...feeQuotesOrData,
            tokenList
        });
    }
    /**
     *
     * @description This function will retrieve fees from the paymaster in erc20 mode
     *
     * @param manyOrOneTransactions Array of {@link Transaction} to be batched and sent. Can also be a single {@link Transaction}.
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @returns Promise<FeeQuotesOrDataResponse>
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dashboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const feeQuotesResponse: FeeQuotesOrDataResponse = await smartAccount.getTokenFees(transaction, { paymasterServiceData: { mode: PaymasterMode.ERC20 } });
     *
     * const userSeletedFeeQuote = feeQuotesResponse.feeQuotes?.[0];
     *
     * const { wait } = await smartAccount.sendTransaction(transaction, {
     *    paymasterServiceData: {
     *      mode: PaymasterMode.ERC20,
     *      feeQuote: userSeletedFeeQuote,
     *      spender: feeQuotesResponse.tokenPaymasterAddress,
     *    },
     * });
     *
     * const { success, receipt } = await wait();
     *
     */ async getTokenFees(manyOrOneTransactions, buildUseropDto) {
        const txs = Array.isArray(manyOrOneTransactions) ? manyOrOneTransactions : [
            manyOrOneTransactions
        ];
        const userOp = await this.buildUserOp(txs, buildUseropDto);
        if (!buildUseropDto.paymasterServiceData) throw new Error("paymasterServiceData was not provided");
        return this.getPaymasterFeeQuotesOrData(userOp, buildUseropDto.paymasterServiceData);
    }
    /**
     *
     * @description This function will return an array of supported tokens from the erc20 paymaster associated with the Smart Account
     * @returns Promise<{@link SupportedToken}>
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl, biconomyPaymasterApiKey }); // Retrieve bundler url from dashboard
     * const tokens = await smartAccount.getSupportedTokens();
     *
     * // [
     * //   {
     * //     symbol: "USDC",
     * //     tokenAddress: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
     * //     decimal: 6,
     * //     logoUrl: "https://assets.coingecko.com/coins/images/279/large/usd-coin.png?1595353707",
     * //     premiumPercentage: 0.1,
     * //   }
     * // ]
     *
     */ async getSupportedTokens() {
        const feeQuotesResponse = await this.getTokenFees({
            data: "0x",
            value: BigInt(0),
            to: await this.getAccountAddress()
        }, {
            paymasterServiceData: {
                mode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].ERC20
            }
        });
        return await Promise.all((feeQuotesResponse?.feeQuotes ?? []).map(async (quote)=>{
            const [tokenBalance] = await this.getBalances([
                quote.tokenAddress
            ]);
            return {
                symbol: quote.symbol,
                tokenAddress: quote.tokenAddress,
                decimal: quote.decimal,
                logoUrl: quote.logoUrl,
                premiumPercentage: quote.premiumPercentage,
                balance: tokenBalance
            };
        }));
    }
    /**
     *
     * @param userOp
     * @param params
     * @description This function will take a user op as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     * Sends a user operation
     *
     * - Docs: https://docs.biconomy.io/Account/methods#senduserop-
     *
     * @param userOp Partial<{@link UserOperationStruct}> the userOp params to be sent.
     * @param params {@link SendUserOpParams}.
     * @returns Promise<{@link UserOpResponse}> that you can use to track the user operation.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dashboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const userOp = await smartAccount.buildUserOp([transaction]);
     *
     * const { wait } = await smartAccount.sendUserOp(userOp);
     * const { success, receipt } = await wait();
     *
     */ async sendUserOp(userOp, params) {
        // biome-ignore lint/performance/noDelete: <explanation>
        delete userOp.signature;
        const userOperation = await this.signUserOp(userOp, params);
        const bundlerResponse = await this.sendSignedUserOp(userOperation);
        return bundlerResponse;
    }
    /**
     *
     * @param userOp - The signed user operation to send
     * @param simulationType - The type of simulation to perform ("validation" | "validation_and_execution")
     * @description This function call will take 'signedUserOp' as input and send it to the bundler
     * @returns
     */ async sendSignedUserOp(userOp, simulationType) {
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData",
            "callGasLimit",
            "verificationGasLimit",
            "preVerificationGas",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "paymasterAndData",
            "signature"
        ];
        this.validateUserOp(userOp, requiredFields);
        if (!this.bundler) throw new Error("Bundler is not provided");
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn("userOp being sent to the bundler", JSON.stringify(userOp, null, 2));
        const bundlerResponse = await this.bundler.sendUserOp(userOp, simulationType);
        return bundlerResponse;
    }
    async getUserOpHash(userOp) {
        const userOpHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["packUserOp"])(userOp, true));
        const enc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("bytes32, address, uint256"), [
            userOpHash,
            this.entryPoint.address,
            BigInt(this.chainId)
        ]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$client$5d$__$28$ecmascript$29$__["keccak256"])(enc);
    }
    async estimateUserOpGas(userOp, stateOverrideSet) {
        if (!this.bundler) throw new Error("Bundler is not provided");
        const requiredFields = [
            "sender",
            "nonce",
            "initCode",
            "callData"
        ];
        this.validateUserOp(userOp, requiredFields);
        const finalUserOp = userOp;
        // Making call to bundler to get gas estimations for userOp
        const { callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = await this.bundler.estimateUserOpGas(userOp, stateOverrideSet);
        // if neither user sent gas fee nor the bundler, estimate gas from provider
        if (!userOp.maxFeePerGas && !userOp.maxPriorityFeePerGas && (!maxFeePerGas || !maxPriorityFeePerGas)) {
            const feeData = await this.provider.estimateFeesPerGas();
            if (feeData.maxFeePerGas?.toString()) {
                finalUserOp.maxFeePerGas = `0x${feeData.maxFeePerGas.toString(16)}`;
            } else if (feeData.gasPrice?.toString()) {
                finalUserOp.maxFeePerGas = `0x${feeData.gasPrice.toString(16)}`;
            } else {
                finalUserOp.maxFeePerGas = `0x${(await this.provider.getGasPrice()).toString(16)}`;
            }
            if (feeData.maxPriorityFeePerGas?.toString()) {
                finalUserOp.maxPriorityFeePerGas = `0x${feeData.maxPriorityFeePerGas?.toString()}`;
            } else if (feeData.gasPrice?.toString()) {
                finalUserOp.maxPriorityFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number(feeData.gasPrice?.toString()));
            } else {
                finalUserOp.maxPriorityFeePerGas = `0x${(await this.provider.getGasPrice()).toString(16)}`;
            }
        } else {
            finalUserOp.maxFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number(maxFeePerGas)) ?? userOp.maxFeePerGas;
            finalUserOp.maxPriorityFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number(maxPriorityFeePerGas)) ?? userOp.maxPriorityFeePerGas;
        }
        finalUserOp.verificationGasLimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number(verificationGasLimit)) ?? userOp.verificationGasLimit;
        finalUserOp.callGasLimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number(callGasLimit)) ?? userOp.callGasLimit;
        finalUserOp.preVerificationGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number(preVerificationGas)) ?? userOp.preVerificationGas;
        if (!finalUserOp.paymasterAndData) {
            finalUserOp.paymasterAndData = "0x";
        }
        return finalUserOp;
    }
    async getNonce(nonceKey) {
        const nonceSpace = nonceKey ?? 0;
        try {
            const address = await this.getAddress();
            return await this.entryPoint.read.getNonce([
                address,
                BigInt(nonceSpace)
            ]);
        } catch (e) {
            return BigInt(0);
        }
    }
    async getBuildUserOpNonce(nonceOptions) {
        let nonce = BigInt(0);
        try {
            if (nonceOptions?.nonceOverride) {
                nonce = BigInt(nonceOptions?.nonceOverride);
            } else {
                const _nonceSpace = nonceOptions?.nonceKey ?? 0;
                nonce = await this.getNonce(_nonceSpace);
            }
        } catch (error) {
            // Not throwing this error as nonce would be 0 if this.getNonce() throw exception, which is expected flow for undeployed account
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn("Error while getting nonce for the account. This is expected for undeployed accounts set nonce to 0");
        }
        return nonce;
    }
    /**
     * Transfers ownership of the smart account to a new owner.
     * @param newOwner The address of the new owner.
     * @param moduleAddress {@link TransferOwnershipCompatibleModule} The address of the validation module (ECDSA Ownership Module or Multichain Validation Module).
     * @param buildUseropDto {@link BuildUserOpOptions}. Optional parameter
     * @returns A Promise that resolves to a UserOpResponse or rejects with an Error.
     * @description This function will transfer ownership of the smart account to a new owner. If you use session key manager module, after transferring the ownership
     * you will need to re-create a session for the smart account with the new owner (signer) and specify "accountAddress" in "createSmartAccountClient" function.
     * @example
     *
     * let walletClient = createWalletClient({
          account,
          chain: baseSepolia,
          transport: http()
        });
  
        let smartAccount = await createSmartAccountClient({
          signer: walletClient,
          paymasterUrl: "https://paymaster.biconomy.io/api/v1/...",
          bundlerUrl: `https://bundler.biconomy.io/api/v2/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44`,
          chainId: 84532
        });
        const response = await smartAccount.transferOwnership(newOwner, DEFAULT_ECDSA_OWNERSHIP_MODULE, {paymasterServiceData: {mode: PaymasterMode.SPONSORED}});
        
        walletClient = createWalletClient({
          newOwnerAccount,
          chain: baseSepolia,
          transport: http()
        })
        
        smartAccount = await createSmartAccountClient({
          signer: walletClient,
          paymasterUrl: "https://paymaster.biconomy.io/api/v1/...",
          bundlerUrl: `https://bundler.biconomy.io/api/v2/84532/nJPK7B3ru.dd7f7861-190d-41bd-af80-6877f74b8f44`,
          chainId: 84532,
          accountAddress: await smartAccount.getAccountAddress()
        })
     */ async transferOwnership(newOwner, moduleAddress, buildUseropDto) {
        const encodedCall = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbi"])([
                "function transferOwnership(address newOwner) public"
            ]),
            functionName: "transferOwnership",
            args: [
                newOwner
            ]
        });
        const transaction = {
            to: moduleAddress,
            data: encodedCall
        };
        const userOpResponse = await this.sendTransaction(transaction, buildUseropDto);
        return userOpResponse;
    }
    /**
     * Sends a transaction (builds and sends a user op in sequence)
     *
     * - Docs: https://docs.biconomy.io/Account/methods#sendtransaction-
     *
     * @param manyOrOneTransactions Array of {@link Transaction} to be batched and sent. Can also be a single {@link Transaction}.
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @param sessionData - Optional parameter. If you are using session keys, you can pass the sessionIds, the session and the storage client to retrieve the session data while sending a tx {@link GetSessionParams}
     * @returns Promise<{@link UserOpResponse}> that you can use to track the user operation.
     *
     * @example
     * ```ts
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dashboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const { waitForTxHash } = await smartAccount.sendTransaction(transaction);
     * const { transactionHash, userOperationReceipt } = await wait();
     * ```
     */ async sendTransaction(manyOrOneTransactions, buildUseropDto, sessionData) {
        let defaultedBuildUseropDto = {
            ...buildUseropDto
        } ?? {};
        if (this.sessionType && sessionData) {
            const store = this.sessionStorageClient ?? sessionData?.store;
            const getSessionParameters = await this.getSessionParams({
                ...sessionData,
                store,
                txs: manyOrOneTransactions
            });
            defaultedBuildUseropDto = {
                ...defaultedBuildUseropDto,
                ...getSessionParameters
            };
        }
        const userOp = await this.buildUserOp(Array.isArray(manyOrOneTransactions) ? manyOrOneTransactions : [
            manyOrOneTransactions
        ], defaultedBuildUseropDto);
        return this.sendUserOp(userOp, {
            ...defaultedBuildUseropDto?.params
        });
    }
    /**
     * Retrieves the session parameters for sending the session transaction
     *
     * @description This method is called under the hood with the third argument passed into the smartAccount.sendTransaction(...args) method. It is used to retrieve the relevant session parameters while sending the session transaction.
     *
     * @param leafIndex - The leaf index(es) of the session in the storage client to be used. If you want to use the last leaf index, you can pass "LAST_LEAVES" as the value.
     * @param store - The {@link ISessionStorage} client to be used. If you want to use the default storage client (localStorage in the browser), you can pass "DEFAULT_STORE" as the value. Alternatively you can pass in {@link SessionSearchParam} for more control over how the leaves are stored and retrieved.
     * @param chain - Optional, will be inferred if left unset
     * @param txs - Optional, used only for validation while using Batched session type
     * @returns Promise<{@link GetSessionParams}>
     *
     * @example
     * ```ts
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dashboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const { waitForTxHash } = await smartAccount.sendTransaction(transaction);
     * const { transactionHash, userOperationReceipt } = await wait();
     * ```
     */ async getSessionParams({ leafIndex, store, chain, txs }) {
        const accountAddress = await this.getAccountAddress();
        const defaultedTransactions = txs ? Array.isArray(txs) ? [
            ...txs
        ] : [
            txs
        ] : [];
        const defaultedConditionalSession = store === "DEFAULT_STORE" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$session$2d$storage$2f$utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getDefaultStorageClient"])(accountAddress) : store ?? await this.getAccountAddress();
        const defaultedCorrespondingIndexes = [
            "LAST_LEAF",
            "LAST_LEAVES"
        ].includes(String(leafIndex)) ? null : leafIndex ? Array.isArray(leafIndex) ? leafIndex : [
            leafIndex
        ] : null;
        const correspondingIndex = defaultedCorrespondingIndexes ? defaultedCorrespondingIndexes[0] : null;
        const defaultedChain = chain ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$getChain$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getChain"])(await this.provider.getChainId());
        if (!defaultedChain) throw new Error("Chain is not provided");
        if (this.sessionType === "DISTRIBUTED_KEY") {
        // return getDanSessionTxParams(
        //   defaultedConditionalSession,
        //   defaultedChain,
        //   correspondingIndex
        // )
        }
        if (this.sessionType === "BATCHED") {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$sessions$2f$batch$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getBatchSessionTxParams"])(defaultedTransactions, defaultedCorrespondingIndexes, defaultedConditionalSession, defaultedChain);
        }
        if (this.sessionType === "STANDARD") {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$modules$2f$sessions$2f$abi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getSingleSessionTxParams"])(defaultedConditionalSession, defaultedChain, correspondingIndex);
        }
        throw new Error("Session type is not provided");
    }
    /**
     * Builds a user operation
     *
     * This method will also simulate the validation and execution of the user operation, telling the user if the user operation will be successful or not.
     *
     * - Docs: https://docs.biconomy.io/Account/methods#builduserop-
     *
     * @param transactions Array of {@link Transaction} to be sent.
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @returns Promise<Partial{@link UserOperationStruct}>> the built user operation to be sent.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({ signer, bundlerUrl }); // Retrieve bundler url from dashboard
     * const encodedCall = encodeFunctionData({
     *   abi: parseAbi(["function safeMint(address to) public"]),
     *   functionName: "safeMint",
     *   args: ["0x..."],
     * });
     *
     * const transaction = {
     *   to: nftAddress,
     *   data: encodedCall
     * }
     *
     * const userOp = await smartAccount.buildUserOp([{ to: "0x...", data: encodedCall }]);
     *
     */ async buildUserOp(transactions, buildUseropDto) {
        const to = transactions.map((element)=>element.to);
        const data = transactions.map((element)=>element.data ?? "0x");
        const value = transactions.map((element)=>element.value ?? BigInt(0));
        const initCodeFetchPromise = this.getInitCode();
        const dummySignatureFetchPromise = this.getDummySignatures(buildUseropDto?.params);
        const [nonceFromFetch, initCode, signature] = await Promise.all([
            this.getBuildUserOpNonce(buildUseropDto?.nonceOptions),
            initCodeFetchPromise,
            dummySignatureFetchPromise
        ]);
        const sender = await this.getAccountAddress();
        if (transactions.length === 0) {
            throw new Error("Transactions array cannot be empty");
        }
        let callData = "0x";
        if (!buildUseropDto?.useEmptyDeployCallData) {
            if (transactions.length > 1 || buildUseropDto?.forceEncodeForBatch) {
                callData = await this.encodeExecuteBatch(to, value, data);
            } else {
                // transactions.length must be 1
                callData = await this.encodeExecute(to[0], value[0], data[0]);
            }
        }
        let userOp = {
            sender,
            nonce: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(nonceFromFetch),
            initCode,
            callData
        };
        // for this Smart Account current validation module dummy signature will be used to estimate gas
        userOp.signature = signature;
        userOp.paymasterAndData = buildUseropDto?.dummyPndOverride ?? "0x";
        if (buildUseropDto?.paymasterServiceData && buildUseropDto?.paymasterServiceData.mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$utils$2f$Types$2e$js__$5b$client$5d$__$28$ecmascript$29$__["PaymasterMode"].SPONSORED && this.paymaster instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$BiconomyPaymaster$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyPaymaster"]) {
            const gasFeeValues = await this.bundler?.getGasFeeValues();
            // populate gasfee values and make a call to paymaster
            userOp.maxFeePerGas = gasFeeValues?.maxFeePerGas;
            userOp.maxPriorityFeePerGas = gasFeeValues?.maxPriorityFeePerGas;
            if (buildUseropDto.gasOffset) {
                userOp = await this.estimateUserOpGas(userOp);
                const { verificationGasLimitOffsetPct, preVerificationGasOffsetPct, callGasLimitOffsetPct, maxFeePerGasOffsetPct, maxPriorityFeePerGasOffsetPct } = buildUseropDto.gasOffset;
                userOp.verificationGasLimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.verificationGasLimit ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(verificationGasLimitOffsetPct)).toString()));
                userOp.preVerificationGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.preVerificationGas ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(preVerificationGasOffsetPct)).toString()));
                userOp.callGasLimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.callGasLimit ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(callGasLimitOffsetPct)).toString()));
                userOp.maxFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.maxFeePerGas ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(maxFeePerGasOffsetPct)).toString()));
                userOp.maxPriorityFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.maxPriorityFeePerGas ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(maxPriorityFeePerGasOffsetPct)).toString()));
                userOp = await this.getPaymasterUserOp(userOp, {
                    ...buildUseropDto.paymasterServiceData,
                    calculateGasLimits: false
                });
                return userOp;
            }
            if (buildUseropDto.paymasterServiceData.calculateGasLimits === false) {
                userOp = await this.estimateUserOpGas(userOp);
            }
            userOp = await this.getPaymasterUserOp(userOp, buildUseropDto.paymasterServiceData);
            return userOp;
        }
        userOp = await this.estimateUserOpGas(userOp);
        if (buildUseropDto?.gasOffset) {
            if (buildUseropDto?.paymasterServiceData) {
                userOp = await this.getPaymasterUserOp(userOp, {
                    ...buildUseropDto.paymasterServiceData,
                    calculateGasLimits: false
                });
            }
            const { verificationGasLimitOffsetPct, preVerificationGasOffsetPct, callGasLimitOffsetPct, maxFeePerGasOffsetPct, maxPriorityFeePerGasOffsetPct } = buildUseropDto.gasOffset;
            userOp.verificationGasLimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.verificationGasLimit ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(verificationGasLimitOffsetPct)).toString()));
            userOp.preVerificationGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.preVerificationGas ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(preVerificationGasOffsetPct)).toString()));
            userOp.callGasLimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.callGasLimit ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(callGasLimitOffsetPct)).toString()));
            userOp.maxFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.maxFeePerGas ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(maxFeePerGasOffsetPct)).toString()));
            userOp.maxPriorityFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toHex"])(Number.parseInt((Number(userOp.maxPriorityFeePerGas ?? 0) * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["convertToFactor"])(maxPriorityFeePerGasOffsetPct)).toString()));
            return userOp;
        }
        if (buildUseropDto?.paymasterServiceData) {
            userOp = await this.getPaymasterUserOp(userOp, buildUseropDto.paymasterServiceData);
        }
        return userOp;
    }
    validateUserOpAndPaymasterRequest(userOp, tokenPaymasterRequest) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNullOrUndefined"])(userOp.callData)) {
            throw new Error("UserOp callData cannot be undefined");
        }
        const feeTokenAddress = tokenPaymasterRequest?.feeQuote?.tokenAddress;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn("Requested fee token is ", feeTokenAddress);
        if (!feeTokenAddress || feeTokenAddress === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_ZERO"]) {
            throw new Error("Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest");
        }
        const spender = tokenPaymasterRequest?.spender;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn("Spender address is ", spender);
        if (!spender || spender === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_ZERO"]) {
            throw new Error("Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest");
        }
    }
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */ async buildTokenPaymasterUserOp(userOp, tokenPaymasterRequest) {
        this.validateUserOpAndPaymasterRequest(userOp, tokenPaymasterRequest);
        try {
            let batchTo = [];
            let batchValue = [];
            let batchData = [];
            let newCallData = userOp.callData;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn("Received information about fee token address and quote ", tokenPaymasterRequest.toString());
            if (this.paymaster && this.paymaster instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$paymaster$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Paymaster"]) {
                // Make a call to paymaster.buildTokenApprovalTransaction() with necessary details
                // Review: might request this form of an array of Transaction
                const approvalRequest = await this.paymaster.buildTokenApprovalTransaction(tokenPaymasterRequest);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn("ApprovalRequest is for erc20 token ", approvalRequest.to);
                if (approvalRequest.data === "0x" || approvalRequest.to === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ADDRESS_ZERO"]) {
                    return userOp;
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Utils$2e$js__$5b$client$5d$__$28$ecmascript$29$__["isNullOrUndefined"])(userOp.callData)) {
                    throw new Error("UserOp callData cannot be undefined");
                }
                const decodedSmartAccountData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$decodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["decodeFunctionData"])({
                    abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
                    data: userOp.callData
                });
                if (!decodedSmartAccountData) {
                    throw new Error("Could not parse userOp call data for this smart account");
                }
                const smartAccountExecFunctionName = decodedSmartAccountData.functionName;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].warn(`Originally an ${smartAccountExecFunctionName} method call for Biconomy Account V2`);
                if (smartAccountExecFunctionName === "execute" || smartAccountExecFunctionName === "execute_ncC") {
                    const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;
                    const toOriginal = methodArgsSmartWalletExecuteCall[0];
                    const valueOriginal = methodArgsSmartWalletExecuteCall[1];
                    const dataOriginal = methodArgsSmartWalletExecuteCall[2];
                    batchTo.push(toOriginal);
                    batchValue.push(valueOriginal);
                    batchData.push(dataOriginal);
                } else if (smartAccountExecFunctionName === "executeBatch" || smartAccountExecFunctionName === "executeBatch_y6U") {
                    const methodArgsSmartWalletExecuteCall = decodedSmartAccountData.args;
                    batchTo = [
                        ...methodArgsSmartWalletExecuteCall[0]
                    ];
                    batchValue = [
                        ...methodArgsSmartWalletExecuteCall[1]
                    ];
                    batchData = [
                        ...methodArgsSmartWalletExecuteCall[2]
                    ];
                }
                if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {
                    batchTo = [
                        approvalRequest.to,
                        ...batchTo
                    ];
                    batchValue = [
                        BigInt(Number(approvalRequest.value.toString())),
                        ...batchValue
                    ];
                    batchData = [
                        approvalRequest.data,
                        ...batchData
                    ];
                    newCallData = await this.encodeExecuteBatch(batchTo, batchValue, batchData);
                }
                const finalUserOp = {
                    ...userOp,
                    callData: newCallData
                };
                // Optionally Requesting to update gas limits again (especially callGasLimit needs to be re-calculated)
                return finalUserOp;
            }
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].log("Failed to update userOp. Sending back original op");
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Logger$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Logger"].error("Failed to update callData with error", JSON.stringify(error));
            return userOp;
        }
        return userOp;
    }
    async signUserOpHash(userOpHash, params) {
        this.isActiveValidationModuleDefined();
        const moduleSig = await this.activeValidationModule.signUserOpHash(userOpHash, params);
        const signatureWithModuleAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parseAbiParameters"])("bytes, address"), [
            moduleSig,
            this.activeValidationModule.getAddress()
        ]);
        return signatureWithModuleAddress;
    }
    /**
     * Deploys the smart contract
     *
     * This method will deploy a Smart Account contract. It is useful for deploying in a moment when you know that gas prices are low,
     * and you want to deploy the account before sending the first user operation. This step can otherwise be skipped,
     * as the deployment will alternatively be bundled with the first user operation.
     *
     * @param buildUseropDto {@link BuildUserOpOptions}.
     * @returns Promise<{@link UserOpResponse}> that you can use to track the user operation.
     * @error Throws an error if the account has already been deployed.
     * @error Throws an error if the account has not enough native token balance to deploy, if not using a paymaster.
     *
     * @example
     * import { createClient } from "viem"
     * import { createSmartAccountClient } from "@biconomy/account"
     * import { createWalletClient, http } from "viem";
     * import { polygonAmoy } from "viem/chains";
     *
     * const signer = createWalletClient({
     *   account,
     *   chain: polygonAmoy,
     *   transport: http(),
     * });
     *
     * const smartAccount = await createSmartAccountClient({
     *  signer,
     *  biconomyPaymasterApiKey,
     *  bundlerUrl
     * });
     *
     * // If you want to use a paymaster...
     * const { wait } = await smartAccount.deploy({
     *   paymasterServiceData: { mode: PaymasterMode.SPONSORED },
     * });
     *
     * // Or if you can't use a paymaster send native token to this address:
     * const counterfactualAddress = await smartAccount.getAccountAddress();
     *
     * // Then deploy the account
     * const { wait } = await smartAccount.deploy();
     *
     * const { success, receipt } = await wait();
     *
     */ async deploy(buildUseropDto) {
        const accountAddress = this.accountAddress ?? await this.getAccountAddress();
        // Check that the account has not already been deployed
        const byteCode = await this.provider?.getBytecode({
            address: accountAddress
        });
        if (byteCode !== undefined) {
            throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].ACCOUNT_ALREADY_DEPLOYED);
        }
        // Check that the account has enough native token balance to deploy, if not using a paymaster
        if (!buildUseropDto?.paymasterServiceData?.mode) {
            const nativeTokenBalance = await this.provider?.getBalance({
                address: accountAddress
            });
            if (nativeTokenBalance === BigInt(0)) {
                throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["ERROR_MESSAGES"].NO_NATIVE_TOKEN_BALANCE_DURING_DEPLOY);
            }
        }
        const useEmptyDeployCallData = true;
        return this.sendTransaction({
            to: accountAddress,
            data: "0x"
        }, {
            ...buildUseropDto,
            useEmptyDeployCallData
        });
    }
    async getFactoryData() {
        if (await this.isAccountDeployed()) return undefined;
        this.isDefaultValidationModuleDefined();
        const defaultValidationModuleAddress = this.defaultValidationModule.getAddress();
        const defaultValidationInitData = await this.defaultValidationModule.getInitData();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$Factory$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyFactoryAbi"],
            functionName: "deployCounterFactualAccount",
            args: [
                defaultValidationModuleAddress,
                defaultValidationInitData,
                BigInt(this.index)
            ]
        });
    }
    async signMessage(message) {
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        let signature;
        this.isActiveValidationModuleDefined();
        const dataHash = typeof message === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toBytes"])(message) : message;
        signature = await this.activeValidationModule.signMessage(dataHash);
        const potentiallyIncorrectV = Number.parseInt(signature.slice(-2), 16);
        if (![
            27,
            28
        ].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== "0x") {
            signature = `0x${signature}`;
        }
        signature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])([
            {
                type: "bytes"
            },
            {
                type: "address"
            }
        ], [
            signature,
            this.defaultValidationModule.getAddress()
        ]);
        if (await this.isAccountDeployed()) {
            return signature;
        }
        const abiEncodedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeAbiParameters"])([
            {
                type: "address",
                name: "create2Factory"
            },
            {
                type: "bytes",
                name: "factoryCalldata"
            },
            {
                type: "bytes",
                name: "originalERC1271Signature"
            }
        ], [
            this.getFactoryAddress() ?? "0x",
            await this.getFactoryData() ?? "0x",
            signature
        ]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$client$5d$__$28$ecmascript$29$__["concat"])([
            abiEncodedMessage,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$utils$2f$Constants$2e$js__$5b$client$5d$__$28$ecmascript$29$__["MAGIC_BYTES"]
        ]);
    }
    async getIsValidSignatureData(messageHash, signature) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
            functionName: "isValidSignature",
            args: [
                messageHash,
                signature
            ]
        });
    }
    async enableModule(moduleAddress) {
        const tx = await this.getEnableModuleData(moduleAddress);
        const partialUserOp = await this.buildUserOp([
            tx
        ]);
        return this.sendUserOp(partialUserOp);
    }
    async getEnableModuleData(moduleAddress) {
        const callData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
            functionName: "enableModule",
            args: [
                moduleAddress
            ]
        });
        const tx = {
            to: await this.getAddress(),
            value: "0x00",
            data: callData
        };
        return tx;
    }
    async getSetupAndEnableModuleData(moduleAddress, moduleSetupData) {
        const callData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
            functionName: "setupAndEnableModule",
            args: [
                moduleAddress,
                moduleSetupData
            ]
        });
        const tx = {
            to: await this.getAddress(),
            value: "0x00",
            data: callData
        };
        return tx;
    }
    async disableModule(prevModule, moduleAddress) {
        const tx = await this.getDisableModuleData(prevModule, moduleAddress);
        const partialUserOp = await this.buildUserOp([
            tx
        ]);
        return this.sendUserOp(partialUserOp);
    }
    async getDisableModuleData(prevModule, moduleAddress) {
        const callData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$client$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
            abi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$abi$2f$SmartAccount$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomyAccountAbi"],
            functionName: "disableModule",
            args: [
                prevModule,
                moduleAddress
            ]
        });
        const tx = {
            to: await this.getAddress(),
            value: "0x00",
            data: callData
        };
        return tx;
    }
    async isModuleEnabled(moduleAddress) {
        const accountContract = await this._getAccountContract();
        return accountContract.read.isModuleEnabled([
            moduleAddress
        ]);
    }
    // Review
    async getAllModules(pageSize) {
        const _pageSize = pageSize ?? 100;
        const accountContract = await this._getAccountContract();
        const result = await accountContract.read.getModulesPaginated([
            this.SENTINEL_MODULE,
            BigInt(_pageSize)
        ]);
        const modules = result[0];
        return modules;
    }
} //# sourceMappingURL=BiconomySmartAccountV2.js.map
}),
"[project]/node_modules/@biconomy/account/dist/_esm/account/index.js [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSmartAccountClient",
    ()=>createSmartAccountClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$BiconomySmartAccountV2$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@biconomy/account/dist/_esm/account/BiconomySmartAccountV2.js [client] (ecmascript)");
;
;
;
;
;
const createSmartAccountClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$biconomy$2f$account$2f$dist$2f$_esm$2f$account$2f$BiconomySmartAccountV2$2e$js__$5b$client$5d$__$28$ecmascript$29$__["BiconomySmartAccountV2"].create; //# sourceMappingURL=index.js.map
}),
]);

//# sourceMappingURL=node_modules_%40biconomy_account_dist__esm_273d91f0._.js.map